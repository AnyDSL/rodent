// Trace function ------------------------------------------------------------------

fn @cpu_parallel_tiles( width: i32
                      , height: i32
                      , tile_width: i32
                      , tile_height: i32
                      , num_cores: i32
                      , body: fn (i32, i32, i32, i32) -> ()) -> () {
    let num_tiles_x = round_up(width , tile_width)  / tile_width;
    let num_tiles_y = round_up(height, tile_height) / tile_height;
    let num_tiles = num_tiles_x * num_tiles_y;
    let tiles_div = make_fast_div(num_tiles_x as u32);

    for i in parallel(num_cores, 0, num_tiles) {
        let y = fast_div(tiles_div, i as u32) as i32;
        let x = i - num_tiles_x * y;
        let xmin = x * tile_width;
        let ymin = y * tile_height;
        let xmax = cpu_intrinsics.min(xmin + tile_width,  width);
        let ymax = cpu_intrinsics.min(ymin + tile_height, height);
        @@body(xmin, ymin, xmax, ymax);
    }
}

fn @cpu_sort_primary(scene: Scene, primary: PrimaryStream, ray_begins: &mut [i32], ray_ends: &mut[i32]) -> i32 {
    let read_primary_hit = make_primary_stream_hit_reader(primary, 1);

    // Count the number of rays per shader
    for i in range(0, scene.num_geometries + 1) {
        ray_ends(i) = 0;
    }
    for i in range(0, primary.size) {
        ray_ends(primary.geom_id(i))++;
    }
    // Compute scan over shader bins
    let mut n = 0;
    for i in range(0, scene.num_geometries + 1) {
        ray_begins(i) = n;
        n += ray_ends(i);
        ray_ends(i) = n;
    }

    // Sort by shader
    for i in range(0, scene.num_geometries) {
        let (begin, end) = (ray_begins(i), ray_ends(i));
        let mut j = begin;
        while j < end {
            let geom_id = primary.geom_id(j);
            if geom_id != i {
                let k = ray_begins(geom_id)++;

                swap_i32(&mut primary.rays.id(k),    &mut primary.rays.id(j));
                swap_f32(&mut primary.rays.org_x(k), &mut primary.rays.org_x(j));
                swap_f32(&mut primary.rays.org_y(k), &mut primary.rays.org_y(j));
                swap_f32(&mut primary.rays.org_z(k), &mut primary.rays.org_z(j));
                swap_f32(&mut primary.rays.dir_x(k), &mut primary.rays.dir_x(j));
                swap_f32(&mut primary.rays.dir_y(k), &mut primary.rays.dir_y(j));
                swap_f32(&mut primary.rays.dir_z(k), &mut primary.rays.dir_z(j));
                swap_f32(&mut primary.rays.tmin(k),  &mut primary.rays.tmin(j));
                swap_f32(&mut primary.rays.tmax(k),  &mut primary.rays.tmax(j));

                swap_i32(&mut primary.geom_id(k),   &mut primary.geom_id(j));
                swap_i32(&mut primary.prim_id(k),   &mut primary.prim_id(j));
                swap_f32(&mut primary.t(k),         &mut primary.t(j));
                swap_f32(&mut primary.u(k),         &mut primary.u(j));
                swap_f32(&mut primary.v(k),         &mut primary.v(j));
                swap_u32(&mut primary.rnd(k),       &mut primary.rnd(j));
                swap_f32(&mut primary.mis(k),       &mut primary.mis(j));
                swap_f32(&mut primary.contrib_r(k), &mut primary.contrib_r(j));
                swap_f32(&mut primary.contrib_g(k), &mut primary.contrib_g(j));
                swap_f32(&mut primary.contrib_b(k), &mut primary.contrib_b(j));
                swap_i32(&mut primary.depth(k),     &mut primary.depth(j));
            } else {
                j++;
            }
        }
    }

    // Kill rays that have not intersected anything
    ray_ends(scene.num_geometries - 1)
}

fn @cpu_permute_ray_stream(rays: RayStream, i: i32, j: i32, perm: Perm) -> () {
    rays.org_x(i) = cpu_permute_f32(rays.org_x(j), perm);
    rays.org_y(i) = cpu_permute_f32(rays.org_y(j), perm);
    rays.org_z(i) = cpu_permute_f32(rays.org_z(j), perm);
    rays.dir_x(i) = cpu_permute_f32(rays.dir_x(j), perm);
    rays.dir_y(i) = cpu_permute_f32(rays.dir_y(j), perm);
    rays.dir_z(i) = cpu_permute_f32(rays.dir_z(j), perm);
    rays.tmin(i)  = cpu_permute_f32(rays.tmin(j), perm);
    rays.tmax(i)  = cpu_permute_f32(rays.tmax(j), perm);
}

fn @cpu_compact_primary(primary: PrimaryStream) -> i32 {
    let lut = generate_compaction_lut();
    let mut k = 0;
    for i in range_step(0, primary.size, 8) {
        let d = primary.size - i;
        let valid_mask = if d < 8 { (1 << d) - 1 } else { -1 };
        for j in vectorize(8) {
            let id = primary.rays.id(i + j);
            let mask = rv_ballot(id >= 0) & valid_mask;
            let perm = lut(mask);

            primary.rays.id(k + j) = cpu_permute_i32(id, perm);

            cpu_permute_ray_stream(primary.rays, k + j, i + j, perm);

            primary.rnd(k + j)       = cpu_permute_u32(primary.rnd(i + j), perm);
            primary.mis(k + j)       = cpu_permute_f32(primary.mis(i + j), perm);
            primary.contrib_r(k + j) = cpu_permute_f32(primary.contrib_r(i + j), perm);
            primary.contrib_g(k + j) = cpu_permute_f32(primary.contrib_g(i + j), perm);
            primary.contrib_b(k + j) = cpu_permute_f32(primary.contrib_b(i + j), perm);
            primary.depth(k + j)     = cpu_permute_i32(primary.depth(i + j), perm);

            k += cpu_popcount32(mask);
        }
    }
    k
}

fn @cpu_compact_secondary(secondary: SecondaryStream) -> i32 {
    let lut = generate_compaction_lut();
    let mut k = 0;
    for i in range_step(0, secondary.size, 8) {
        let d = secondary.size - i;
        let valid_mask = if d < 8 { (1 << d) - 1 } else { -1 };
        for j in vectorize(8) {
            let id = secondary.rays.id(i + j);
            let mask = rv_ballot(id >= 0) & valid_mask;
            let perm = lut(mask);

            secondary.rays.id(k + j) = cpu_permute_i32(id, perm);

            cpu_permute_ray_stream(secondary.rays, k + j, i + j, perm);

            secondary.prim_id(k + j) = cpu_permute_i32(secondary.prim_id(i + j), perm);
            secondary.color_r(k + j) = cpu_permute_f32(secondary.color_r(i + j), perm);
            secondary.color_g(k + j) = cpu_permute_f32(secondary.color_g(i + j), perm);
            secondary.color_b(k + j) = cpu_permute_f32(secondary.color_b(i + j), perm);

            k += cpu_popcount32(mask);
        }
    }
    k
}

fn @cpu_generate_rays( primary: PrimaryStream
                     , capacity: i32
                     , path_tracer: PathTracer
                     , id: &mut i32
                     , xmin: i32
                     , ymin: i32
                     , xmax: i32
                     , ymax: i32
                     , film_width: i32
                     , film_height: i32
                     , spp: i32
                     , vector_width: i32
                     ) -> i32 {
    let write_ray = make_ray_stream_writer(primary.rays, 1);
    let write_state = make_primary_stream_state_writer(primary, 1);
    let first_id = *id;
    let (tile_width, tile_height) = (xmax - xmin, ymax - ymin);
    let num_rays = cpu_intrinsics.min(spp * tile_width * tile_height - first_id, capacity - primary.size);
    let tile_div = make_fast_div(tile_width as u32);
    for i, _ in vectorized_range(vector_width, 0, num_rays) {
        let in_tile_id = first_id + i;

        // Compute x, y of ray within tile
        let sample = in_tile_id % spp;
        let in_tile_pixel = in_tile_id / spp;
        let in_tile_y = fast_div(tile_div, in_tile_pixel as u32) as i32;
        let in_tile_x = in_tile_pixel - in_tile_y * tile_width;
        let x = xmin + in_tile_x;
        let y = ymin + in_tile_y;
        let (ray, state) = @@(path_tracer.on_emit)(sample, x, y, film_width, film_height);
        let cur_ray = primary.size + i;
        write_ray(cur_ray, 0, ray);
        write_state(cur_ray, 0, state);
        primary.rays.id(cur_ray) = y * film_width + x;
    }
    *id = first_id + num_rays;
    primary.size + num_rays
}

fn @cpu_get_film_data() -> (&mut [f32], i32, i32) {
    let mut film_pixels : &mut [f32];
    let mut film_width  : i32;
    let mut film_height : i32;
    rodent_get_film_data(0, &mut film_pixels, &mut film_width, &mut film_height);
    (film_pixels, film_width, film_height)
}

fn @cpu_trace( scene: Scene
             , path_tracer: PathTracer
             , min_max: MinMax
             , single: bool
             , tile_size: i32
             , spp: i32
             , num_cores: i32
             , vector_width: i32
             ) -> () {
    let (film_pixels, film_width, film_height) = cpu_get_film_data();

    fn @accumulate(pixel: i32, color: Color) -> () {
        let inv = 1.0f / (spp as f32);
        film_pixels(pixel * 3 + 0) += color.r * inv;
        film_pixels(pixel * 3 + 1) += color.g * inv;
        film_pixels(pixel * 3 + 2) += color.b * inv;
    }
    for xmin, ymin, xmax, ymax in cpu_parallel_tiles(film_width, film_height, tile_size, tile_size, num_cores) {
        // Get ray streams/states from the CPU driver
        let mut primary   : PrimaryStream;
        let mut secondary : SecondaryStream;
        let capacity = spp * tile_size * tile_size;
        rodent_cpu_get_primary_stream(&mut primary,     capacity);
        rodent_cpu_get_secondary_stream(&mut secondary, capacity);

        let mut id = 0;
        let num_rays = spp * (ymax - ymin) * (xmax - xmin);
        while id < num_rays || primary.size > 0 {
            // (Re-)generate primary rays
            if primary.size < capacity {
                primary.size = cpu_generate_rays(primary, capacity, path_tracer, &mut id, xmin, ymin, xmax, ymax, film_width, film_height, spp, vector_width);
            }

            // Trace primary rays
            cpu_traverse_hybrid(
                min_max,
                scene.bvh,
                make_ray_stream_reader(primary.rays, vector_width),
                make_primary_stream_hit_writer(primary, vector_width, scene.num_geometries),
                vector_width /*packet_size*/,
                primary.size / vector_width + select(primary.size % vector_width != 0, 1, 0),
                single,
                false /*any_hit*/
            );

            // Sort hits by shader id, and filter invalid hits
            let mut ray_begins : [i32 * 1024];
            let mut ray_ends   : [i32 * 1024];
            primary.size = cpu_sort_primary(scene, primary, &mut ray_begins, &mut ray_ends);

            // Perform (vectorized) shading
            let mut begin = 0;
            for geom_id in unroll(0, scene.num_geometries) {
                let read_primary_ray    = make_ray_stream_reader(primary.rays, 1);
                let read_primary_hit    = make_primary_stream_hit_reader(primary, 1);
                let read_primary_state  = make_primary_stream_state_reader(primary, 1);
                let write_primary_ray   = make_ray_stream_writer(primary.rays, 1);
                let write_primary_state = make_primary_stream_state_writer(primary, 1);
                let write_secondary_ray = make_ray_stream_writer(secondary.rays, 1);

                let end = ray_ends(geom_id);
                for i, vector_width in vectorized_range(vector_width, begin, end) {
                    let ray       = read_primary_ray(i, 0);
                    let hit       = read_primary_hit(i, 0);
                    let mut state = read_primary_state(i, 0);
                    let ray_id    = primary.rays.id(i);

                    let geom   = scene.geometries(geom_id);
                    let surf   = geom.surface_element(ray, hit);
                    let mat    = geom.shader(ray, hit, surf);

                    // Execute hit point shading, and add the contribution of each lane to the frame buffer
                    let mut hit_color;
                    for once() {
                        @@(path_tracer.on_hit)(ray, hit, &mut state, surf, mat, @ |color| -> ! {
                            hit_color = color;
                            break()
                        }, @ || -> ! {
                            hit_color = make_color(0.0f, 0.0f, 0.0f);
                            break()
                        })
                    }
                    for lane in unroll(0, vector_width) {
                        let j = bitcast[i32](rv_extract(bitcast[f32](ray_id), lane));
                        accumulate(j,
                            make_color(
                                rv_extract(hit_color.r, lane),
                                rv_extract(hit_color.g, lane),
                                rv_extract(hit_color.b, lane)
                            )
                        );
                    }

                    // Compute shadow rays
                    for once() {
                        @@(path_tracer.on_shadow)(ray, hit, &mut state, surf, mat, @ |ray, color| -> ! {
                            write_secondary_ray(i, 0, ray);
                            secondary.color_r(i) = color.r;
                            secondary.color_g(i) = color.g;
                            secondary.color_b(i) = color.b;
                            secondary.rays.id(i) = ray_id;
                            break()
                        }, @ || -> ! {
                            secondary.rays.id(i) = -1;
                            break()
                        })
                    }

                    // Sample new rays
                    for once() {
                        @@(path_tracer.on_bounce)(ray, hit, &mut state, surf, mat, @ |new_ray, new_state| -> ! {
                            write_primary_ray(i, 0, new_ray);
                            write_primary_state(i, 0, new_state);
                            break()
                        }, @ || -> ! {
                            primary.rays.id(i) = -1;
                            break()
                        })
                    }
                }
                begin = end;
            }

            // Filter terminated rays
            secondary.size = primary.size;
            primary.size   = cpu_compact_primary(primary);

            // Compact and trace secondary rays
            secondary.size = cpu_compact_secondary(secondary);
            if likely(secondary.size > 0) {
                cpu_traverse_hybrid(
                    min_max,
                    scene.bvh,
                    make_ray_stream_reader(secondary.rays, vector_width),
                    make_secondary_stream_hit_writer(secondary, vector_width),
                    vector_width /*packet_size*/,
                    secondary.size / vector_width + select(secondary.size % vector_width != 0, 1, 0),
                    single,
                    true /*any_hit*/
                );
            }

            // Add the contribution for secondary rays to the frame buffer
            for i in range(0, secondary.size) {
                if secondary.prim_id(i) < 0 {
                    let j = secondary.rays.id(i);
                    accumulate(j,
                        make_color(
                            secondary.color_r(i),
                            secondary.color_g(i),
                            secondary.color_b(i)
                        )
                    );
                }
            }
        }
    }
}

// CPU device ----------------------------------------------------------------------

fn @make_cpu_device(single: bool, min_max: MinMax, vector_width: i32, num_cores: i32, tile_size: i32) -> Device {
    Device {
        intrinsics: cpu_intrinsics,
        trace: @ |scene, path_tracer, spp| {
            cpu_trace(
                scene,
                path_tracer,
                min_max,
                true /*single*/,
                tile_size,
                spp,
                num_cores,
                vector_width
            )
        },
        present: @ || rodent_present(0),
        load_buffer: @ |filename| {
            let p = rodent_load_buffer(0, filename);
            DeviceBuffer {
                load_f32:  @ |i| (p as &[f32])(i),
                load_i32:  @ |i| (p as &[i32])(i),
                load_vec2: @ |i| { let q = p as &[f32]; make_vec2(q(i * 2 + 0), q(i * 2 + 1)) },
                load_vec3: @ |i| { let q = p as &[f32]; make_vec3(q(i * 3 + 0), q(i * 3 + 1), q(i * 3 + 2)) },
                load_vec4: @ |i| { let v = (p as &[simd[f32 * 4]])(i); make_vec4(v(0), v(1), v(2), v(3)) },
                load_int2: @ |i| { let q = p as &[i32]; (q(i * 2 + 0), q(i * 2 + 1)) },
                load_int3: @ |i| { let q = p as &[i32]; (q(i * 3 + 0), q(i * 3 + 1), q(i * 3 + 2)) },
                load_int4: @ |i| { let v = (p as &[simd[i32 * 4]])(i); (v(0), v(1), v(2), v(3)) }
            }
        },
        load_bvh: @ |filename| {
            if vector_width == 4 {
                let mut nodes;
                let mut tris;
                rodent_load_bvh4_tri4(0, filename, &mut nodes, &mut tris);
                make_cpu_bvh4_tri4(nodes, tris)
            } else {
                let mut nodes;
                let mut tris;
                rodent_load_bvh8_tri4(0, filename, &mut nodes, &mut tris);
                make_cpu_bvh8_tri4(nodes, tris)
            }
        },
        load_png: @ |filename| {
            let mut pixel_data;
            let mut width;
            let mut height;
            rodent_load_png(0, filename, &mut pixel_data, &mut width, &mut height);
            make_image_rgba32(@ |x, y| (pixel_data as &[u32])(y * width + x), width, height)
        },
        load_jpg: @ |filename| {
            let mut pixel_data;
            let mut width;
            let mut height;
            rodent_load_jpg(0, filename, &mut pixel_data, &mut width, &mut height);
            make_image_rgba32(@ |x, y| (pixel_data as &[u32])(y * width + x), width, height)
        }
    }
}

fn @make_avx2_device() -> Device {
    make_cpu_device(true, make_cpu_int_min_max(), 8, 0, 32)
}

fn @make_avx_device() -> Device {
    make_cpu_device(true, make_cpu_default_min_max(), 8, 0, 32)
}

fn @make_sse42_device() -> Device {
    make_cpu_device(true, make_cpu_int_min_max(), 4, 0, 32)
}

fn @make_asimd_device() -> Device {
    make_cpu_device(false, make_cpu_int_min_max(), 4, 0, 32)
}
