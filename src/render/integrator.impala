struct PrimaryRayState {
    pixel:   Vec2,
    rnd:     RndState,
    mis:     float,
    contrib: Color
}

struct ShadowRayState {
    pixel: Vec2,
    contrib: Color
}

fn path_trace(dev: Device, scene: Scene, spp: int) -> () {
    // Light sampling is done uniformly
    let pdf_lightpick = 1.0f / (scene.num_lights as float);
    let sample_light = |rnd| {
        let light_id = rand(rnd);
        dev.math.min(dev.math.abs(light_id), scene.num_lights - 1)
    };

    // Rays start from the camera
    let ray_gen = make_camera_ray_gen(dev.math,
        |rnd, x, y| PrimaryRayState {
            pixel: vec2(x, y),
            rnd: rnd,
            mis: 0.0f,
            contrib: white
        },
        scene.camera(dev),
        scene.viewport(dev),
        spp);

    let process_primary = |surf, mat, ray, hit, shadow_ray, terminate_path, continue_path| {
        let out_dir = vec3_negate(ray.dir);
        let mut rnd = state.rnd;

        // Handle hits on a light source
        if mat.is_emissive {
            let emit = mat.emission(dev.math, out_dir);
            let mis = 1.0f / (1.0f + state.mis * pdf_lightpick * emit.pdf_area);
            dev.film.accumulate(state.pixel, color_mulf(color_mul(state.contrib, emit.intensity), mis))
            terminate_path()
        }

        // Sample direct illumination
        let specular = mat.bsdf.is_specular;
        if !specular {
            let light_id = sample_light(&mut rnd);
            let light = scene.lights(light_id);

            let light_sample = light.sample_direct(dev.math, &mut rnd, surf.point);
            let light_dir = vec3_sub(sample.pos, surf.point);
            let vis = vec3_dot(light_dir, surf.local.col(2));

            if vis > 0 && !is_black(light_sample.intensity) {
                let inv_d = 1.0f / vec3_length(dev.math, light_dir);
                let inv_d2 = inv_d * inv_d;
                let in_dir = vec3_mulf(light_dir, inv_d);

                let pdf_e = if light.has_area { mat.bsdf.pdf(dev.math, in_dir, out_dir) } else { 0.0f };
                let pdf_l = light_sample.pdf_area * pdf_lightpick;

                let cos_e = vis * inv_d;
                let cos_l = light_sample.cos;

                let mis = 1.0f / (1.0f + pdf_e * cos_l * inv_d2 / pdf_l);
                let color = color_mul(mat.eval(dev.math, in_dir, out_dir), color_mul(state.contrib, light_sample.intensity));

                shadow_ray(
                    make_ray(surf.point, light_dir),
                    ShadowRayState {
                        pixel: state.pixel,
                        contrib: color_mulf(color, cos_e * cos_l * inv_d2 * mis / pdf_l)
                    }
                )
            }
        }

        // Terminate path
        let rr_prob = russian_roulette(weight, 0.75f);
        if (sampler() >= rr_prob) terminate_path()

        // Bounce off the surface
        let mat_sample = mat.sample(dev.math, &mut rnd, out, false);
        continue_path(
            make_ray(surf.point, mat_sample.in_dir),
            PrimaryRayState {
                pixel: state.pixel,
                contrib: color_mul(state.contrib, color_mulf(mat_sample.color, 1.0f / (mat_sample.pdf * rr_prob))),
                rnd: rnd,
                mis: if specular { 0.0f } else { 1.0f / mat_sample.pdf }
            }
        )
    };

    let process_shadow = |ray, hit, state| {
        dev.film.accumulate(state.pixel, state.contrib)
    }

    dev.scheduler(ray_gen, process_primary, process_shadow);
}
