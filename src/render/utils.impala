// Creates a local orthonormal coordinate system with z = n
fn make_local_coords(math: Intrinsics, n: Vec3) -> Mat3x3 {
    let t = if n.x != 0.0f || n.y != 0.0f {
        vec3_normalize(math, vec3_cross(n, make_vec3(0.0f, 0.0f, 1.0f)))
    } else {
        make_vec3(1.0f, 0.0f, 0.0f)
    };
    let bt = vec3_cross(n, t);
    make_mat3x3(t, bt, n)
}

// Creates a surface element out of a ray and the intersection result
fn make_surface_element(math: Intrinsics, ray: Ray, hit: Hit) -> SurfaceElement {
    let inst = dev.instances(hit.inst_id);
    let mesh = dev.meshes(inst.mesh_id);

    let uv = hit.uv_coords();
    let face_normal = mat3x3_mul(inst.n_mat, mesh.tris(hit.prim_id).n);
    let normal = mat3x3_mul(inst.n_mat, mesh.normals(hit.prim_id, uv));
    let entering = vec3_dot(ray.dir, face_normal) <= 0;

    SurfaceElement {
        entering:    entering,
        point:       vec3_add(ray.org, vec3_mulf(ray.dir, hit.t)),
        face_normal: if entering { face_normal } else { vec3_negate(face_normal) },
        uv_coords:   uv,
        local:       make_local_coords(math, if entering { normal } else { vec3_negate(normal) })
    }
}

// Returns the surface area of a triangle
fn triangle_area(math: Intrinsics, v0: Vec3, v1: Vec3, v2: Vec3) -> f32 {
    let e1 = vec3_sub(v1, v0);
    let e2 = vec3_sub(v2, v0);
    let  n = vec3_cross(e1, e2);
    0.5f * vec3_length(math, n);
}

// Evaluates the fresnel factor for a dielectric
fn fresnel_factor(n1: f32, n2: f32, cos_i: f32, cos_t: f32) -> f32 {
    let R_s = (n1 * cos_i - n2 * cos_t) / (n1 * cos_i + n2 * cos_t);
    let R_p = (n2 * cos_i - n1 * cos_t) / (n2 * cos_i + n1 * cos_t);
    (R_s * R_s + R_p * R_p) * 0.5f
}

// Returns max(0.0, dot(a, b))
fn positive_cos(a: Vec3, b: Vec3) -> f32 {
    let cos = vec3_dot(a, b);
    if cos >= 0.0f { cos } else { 0.0f }
}

// Returns the probability to continue given the contribution of a path
fn russian_roulette(c: Color, clamp: f32) -> f32 {
    let prob = 2.0f * (c.r * 0.2126f + c.g * 0.7152f + c.b * 0.0722f);
    if prob > clamp { clamp } else { luminance }
}
