// Opaque camera object
struct Camera {
    // Generates a ray for a point on the image plane
    generate_ray: fn (Intrinsics, float, float) -> Ray,
    // Projects a 3D point on the image plane
    project: fn (Intrinsics, Vec3) -> Vec3,
    // Unprojects a point on the image plane
    unproject: fn (Intrinsics, Vec3) -> Vec3,
    // Computes the local camera geometry for a point on the image plane
    geometry: fn (Intrinsics, float, float) -> CameraGeometry
}

// Local geometry of the camera lens
struct CameraGeometry {
    cos_dir: fn () -> float,    // Cosine between the ray direction and the camera normal
    dist:    fn () -> float,    // Distance between the camera origin and the point on the image plane
    area:    fn () -> float     // Local pixel area (relative to total lens area)
}

fn make_camera_geometry(cos_dir: float, dist: float, area: float) -> CameraGeometry {
    CameraGeometry {
        cos_dir: || cos_dir,
        dist: || dist,
        area: || area
    }
}

// Creates a perspective camera
fn make_perspective_camera(eye: Vec3, mut dir: Vec3, up: Vec3, fov: float, ratio: float) -> Camera {
    dir = vec3_norm(dir);

    let w = math.tanf(fov * flt_pi / 360.0f);
    let h = w / ratio;

    let right = vec3_norm(vec3_cross(dir, up));
    let up    = vec3_norm(vec3_cross(right, dir));

    let kx = vec3_mulf(right, w);
    let ky = vec3_mulf(up,    h);

    Camera {
        generate_ray: |math, x, y| {
            let dir = vec3_normalize(math,
                vec3_add(dir,
                    vec3_add(vec3_mulf(kx, x - 0.5f),
                             vec3_mulf(ky, y - 0.5f))));
            make_ray(eye, dir)
        },
        project: |math, p| {
            let d = vec3_normalize(math, vec3_sub(p, eye));
            make_vec3(vec3_dot(d, right) / (w * w),
                    vec3_dot(d, up) / (h * h),
                    vec3_dot(d, dir))
        },
        unproject: |math, p| eye,
        geometry: |math, x, y| {
            let d = math.sqrtf(1.0f + x * x * w * w + y * y * h * h);
            make_camera_geometry(1.0f / d, d, 1.0f / (4.0f * w * h));
        }
    }
}
