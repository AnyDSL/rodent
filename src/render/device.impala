// Rendering device
struct Device {
    math: Intrinsics,

    num_meshes:    int,
    num_instances: int,
    num_textures:  int,

    meshes:    fn (int) -> Mesh,
    instances: fn (int) -> MeshInstance,
    textures:  fn (int) -> Texture,

    scheduler: RayScheduler
}

struct MeshInstance {
    mat:     Mat3x4,    // Transformation matrix
    inv_mat: Mat3x4,    // Inverse of the transformation matrix
    n_mat:   Mat3x3,    // Matrix to transform normals (transpose of the inverse)
    mesh_id: int        // Mesh identifier
}

struct Mesh {
    // Number of triangles in the mesh
    num_tris: int,
    // Number of attributes for this mesh
    num_attrs: int,
    // Direct access to a triangle in the mesh
    tris:  fn (int) -> Tri,
    // Interpolates normals on the mesh
    normals: fn (int, Vec2) -> Vec3
    // Interpolates an attribute on the mesh
    attrs: fn (int, int, Vec2) -> Attribute
}

struct Attribute {
    value: float,
    vec2:  Vec2,
    vec3:  Vec3,
    vec4:  Vec4
}

fn make_attribute_value(f: float) -> Attribute {
    Attribute {
        value: f,
        vec2: make_vec2(f, 0.0f),
        vec3: make_vec3(f, 0.0f, 0.0f),
        vec4: make_vec4(f, 0.0f, 0.0f, 0.0f)
    }
}

fn make_attribute_vec2(v: Vec2) -> Attribute {
    Attribute {
        value: v.x,
        vec2: v,
        vec3: make_vec3(v.x, v.y, 0.0f),
        vec4: make_vec4(v.x, v.y, 0.0f, 0.0f)
    }
}

fn make_attribute_vec3(v: Vec3) -> Attribute {
    Attribute {
        value: v.x,
        vec2: make_vec2(v.x, v.y),
        vec3: v,
        vec4: make_vec4(v.x, v.y, v.z, 0.0f)
    }
}

fn make_attribute_vec4(v: Vec4) -> Attribute {
    Attribute {
        value: v.x,
        vec2: make_vec2(v.x, v.y),
        vec3: make_vec3(v.x, v.y, v.z),
        vec4: v
    }
}
