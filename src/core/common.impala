static flt_eps = 1.1920928955e-07f;
static flt_max = 3.4028234664e+38f;
static flt_min = 1.1754943508e-38f;
static flt_pi = 3.14159265359f;
static flt_sqrt2 = 1.41421356237f;
static flt_sqrt3 = 1.73205080757f;

extern "device" {
    fn "llvm.expect.i1" expect(bool, bool) -> bool;
}

fn @  likely(cond: bool) -> bool { expect(cond,  true) }
fn @unlikely(cond: bool) -> bool { expect(cond, false) }

fn @prodsign(x: f32, y: f32) -> f32 {
    bitcast[f32](bitcast[i32](x) ^ (bitcast[i32](y) & bitcast[i32](0x80000000u)))
}

fn safe_rcp(x: f32) -> f32 {
    let min_rcp = 1e-8f;
    if select(x > 0.0f, x, -x) < min_rcp { prodsign(min_rcp, x) } else { 1.0f / x }
}

fn @ilog2(i: i32) -> i32 {
    fn @(?i) ilog2_helper(i: i32, p: i32) -> i32 {
        if i <= (1 << p) {
            p
        } else {
            ilog2_helper(i, p + 1)
        }
    }
    ilog2_helper(i, 0)
}

fn @lerp(a: f32, b: f32, k: f32) -> f32 {
    (1.0f - k) * a + k * b
}
