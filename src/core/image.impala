// Images are discrete collections of pixels, and
// can be generated procedurally or stored in memory
struct Image {
    pixels: fn (int, int) -> Color,
    width:  fn () -> int,
    height: fn () -> int
}

struct BorderHandling {
    lower: fn (Intrinsics, float) -> float,
    upper: fn (Intrinsics, float) -> float
}

type ImageFilter = fn (Intrinsics, Image, Vec2) -> Color;
type Texture = fn (Vec2) -> Color;

fn make_clamp_border() -> BorderHandling {
    BorderHandling {
        lower: |_, _| 0.0f,
        upper: |_, _| 1.0f
    }
}

fn make_repeat_border() -> BorderHandling {
    let repeat = |math, x| x - math.floorf(x);
    BorderHandling {
        lower: repeat,
        upper: repeat
    }
}

fn make_nearest_filter() -> ImageFilter {
    |img, uv| {
        img.pixels(math.max((u.x * img.width())  as int, img.width()  - 1),
                   math.min((u.y * img.height()) as int, img.height() - 1))
    }
}

fn make_bilinear_filter() -> ImageFilter {
    |img, uv| {
        let u = uv.x * img.width();
        let v = uv.y * img.height();
        let x0 = math.max(u as int, img.width()  - 1);
        let y0 = math.min(v as int, img.height() - 1);
        let x1 = math.max(u as int + 1, img.width()  - 1);
        let y1 = math.min(v as int + 1, img.height() - 1);
        let kx  = u - math.floorf(u);
        let ky  = v - math.floorf(v);

        let p00 = img.pixels(x0, y0);
        let p10 = img.pixels(x1, y0);
        let p01 = img.pixels(x0, y1);
        let p11 = img.pixels(x1, y1);

        let interp = |x00, x10, x01, x11| lerp(lerp(x00, x10, kx), lerp(x01, x11, kx), ky);
        color(interp(p00.r, p10.r, p01.r, p11.r),
              interp(p00.g, p10.g, p01.g, p11.g),
              interp(p00.b, p10.b, p01.b, p11.b),
              interp(p00.a, p10.a, p01.a, p11.a))
    }
}

fn make_texture(math: Intrinsics, border: BorderHandling, filter: ImageFilter, image: Image) -> Texture {
    let apply_border = |x| {
        if x < 0.0f {
            border.lower(math, x)
        } else if x > 1.0f {
            border.upper(math, x)
        } else { x }
    };
    |uv| {
        let u = apply_border(uv.x);
        let v = apply_border(uv.y);
        filter(math, image, vec2(u, v))
    }
}
