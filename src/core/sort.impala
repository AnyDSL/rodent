type SortingNetwork = fn (int, fn (int, int) -> ()) -> ();

fn bose_nelson_sort(n: int, cmp_swap: fn (int, int) -> ()) -> () {
    fn p_star(i: int, len: int) -> () {
        if len > 1 {
            let m = len / 2;
            p_star(i, m);
            p_star((i + m), (len - m));
            p_bracket(i, m, (i + m), (len - m));
        }
    }

    fn p_bracket(i1: int, len1: int, i2: int, len2: int) -> () {
        if len1 == 1 && len2 == 1 {
            cmp_swap(i1, i2);
        } else if len1 == 1 && len2 == 2 {
            cmp_swap(i1, i2 + 1);
            cmp_swap(i1, i2);
        } else if len1 == 2 && len2 == 1 {
            cmp_swap(i1, i2);
            cmp_swap(i1 + 1, i2);
        } else {
            let a = len1 / 2;
            let b = select(len1 % 2 != 0, len2 / 2, (len2 + 1) / 2);
            p_bracket(i1, a, i2, b);
            p_bracket((i1 + a), (len1 - a), (i2 + b), (len2 - b));
            p_bracket((i1 + a), (len1 - a), i2, b);
        }
    }

    p_star(0, n)
}

fn batcher_sort(n: int, cmp_swap: fn (int, int) -> ()) -> () {
    fn merge(i: int, len: int, r: int) -> () {
        let step = r * 2;
        if step < len {
            merge(i, len, step);
            merge(i + r, len, step);
            for k in range_step(i + r, i + len - r, step) {
                // Remove comparators for non-existing elements
                if k < n && k + r < n {
                    cmp_swap(k, k + r)
                }
            }
        } else {
            if i < n && i + r < n {
                cmp_swap(i, i + r)
            }
        }
    }

    fn sort(i: int, len: int) -> () {
        if len > 1 {
            let m = len / 2;
            sort(i, m);
            sort(i + m, m);
            merge(i, len, 1);
        }
    }

    // Compute closest power of two
    let mut p = 1;
    while p < n { p *= 2; }

    sort(0, p)
}

fn bitonic_sort(n: int, cmp_swap: fn (int, int) -> ()) -> () {
    fn compare(dir: bool, i: int, j: int) -> () {
        let d = (j - i) / 2;
        for k in range(i, i + d) {
            cmp_swap(select(dir, k, k + d), select(dir, k + d, k));
        }
    }

    fn merge(dir: bool, i: int, j: int) -> () {
        if i + 1 < j {
            let m = (i + j) / 2;
            compare(dir, i, j);
            merge(dir, i, m);
            merge(dir, m, j);
        }
    }

    fn sort(dir: bool, i: int, j: int) -> () {
        if i + 1 < j {
            let m = (i + j) / 2;
            sort(true, i, m);
            sort(false, m, j);
            merge(dir, i, j);
        }
    }

    sort(true, 0, n)
}
