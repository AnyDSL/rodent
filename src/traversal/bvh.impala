struct Bvh {
    node:     fn (i32) -> Node, // Access to one node of the BVH
    prim:     fn (i32) -> Prim, // Access to one (possibly packed) primitive
    prefetch: fn (i32) -> (),   // Prefetches a leaf or inner node
    arity:    i32,              // Arity of the BVH (number of children per node)
}

struct Node {
    bbox:         fn (i32) -> BBox,             // Loads the bounding box of one child node
    ordered_bbox: fn (i32, RayOctant) -> BBox,  // Loads the bounding box of one child with the given octant order (mapping specific)
    child:        fn (i32) -> i32               // Gets the index of one child node
}

struct Prim {
    intersect: fn (i32, Intrinsics, bool, Ray) -> (bool, Hit),  // Intersects a primitive in the packet
    is_valid:  fn (i32) -> bool,                                // Returns true if the primitive in the packet is valid
    is_last:   bool,                                            // True if this is the last primitive packet in the leaf
    size:      i32                                              // Number of primitives in the packet (must be a constant)
}

struct MultiNode {
    has_available:  fn () -> bool,                      // Returns true if there is a node available for splitting
    get_available:  fn () -> i32,                       // Returns the index of the first available node
    split:          fn (i32, i32, BBox, BBox) -> (),    // Splits a node at the given position and with the given bounding boxes
    insert:         fn (i32, i32, BBox) -> (),          // Inserts a node with the given reference range and bounding box
    set_tested:     fn (i32) -> (),                     // Marks a node as tested so that it does not get processed again
    is_tested:      fn (i32) -> bool,                   // Returns true if the node has already been tested
    sort_by_cost:   fn () -> (),                        // Sorts the nodes by SAH cost
    ref_range:      fn (i32) -> (i32, i32),             // Returns the reference range for a given node
    bbox:           fn (i32) -> BBox,                   // Returns the bounding box for a given node
    cost:           fn (i32) -> f32,                    // Returns the SAH cost of a node
    size:           fn () -> i32                        // Returns the number of nodes
}

type NodeWriter = fn (i32, i32, fn (i32) -> BBox) -> ();
type LeafWriter = fn (i32, i32, fn (i32) -> i32) -> ();
type NodeLinker = fn (bool, i32, i32, i32) -> ();

fn @mark_split_refs(refs: &[i32], flags: &mut [i8], begin: i32, split: i32, end: i32) -> () {
    for i in range(begin, split) { flags(refs(i)) = 0i8 }
    for i in range(split, end)   { flags(refs(i)) = 1i8 }
}

fn @split_refs(tmp: &mut [i32], refs: &mut [i32], flags: &[i8], begin: i32, split: i32, end: i32) -> () {
    let mut i = begin;
    let mut j = split;
    for k in range(begin, end) {
        let r = refs(k);
        if flags(r) != 0i8 {
            tmp(j++) = r;
        } else {
            tmp(i++) = r;
        }
    }
    for i in range(begin, end) { refs(i) = tmp(i) }
}

fn @partition_refs(refs: &mut [i32], n: i32, pred: fn (i32) -> bool) -> i32 {
    let mut i = 0;
    let mut j = n;
    while i < j {
        if pred(refs(i)) {
            swap_i32(&mut refs(i), &mut refs(--j));
        } else {
            i++;
        }
    }
    j
}

fn @sort_refs_linear(refs: &mut [i32], n: i32, cmp: fn (i32, i32) -> bool) -> () {
    // Shell sort
    let gaps = [701, 301, 132, 57, 23, 10, 4, 1];
    let num_gaps = 8;
    for i in range(0, num_gaps) {
        let gap = gaps(i);
        for j in range(gap, n) {
            let tmp = refs(j);
            let mut k = j;
            while k >= gap && cmp(tmp, refs(k - gap)) {
                refs(k) = refs(k - gap);
                k -= gap
            }
            refs(k) = tmp
        }
    }
}

fn @sort_refs(refs: &mut [i32], begin: i32, end: i32, cmp: fn (i32, i32) -> bool) -> () {
    let linear_threshold = 4096;

    let mut stack : [(i32, i32) * 64];
    let mut stack_ptr = 0;
    stack(0) = (begin, end);

    while stack_ptr >= 0 {
        let (begin, end) = stack(stack_ptr--);
        let n = end - begin;
        if n <= 1 {
            continue()
        } else if n < linear_threshold {
            sort_refs_linear(&refs(begin) as &mut [i32], n, cmp);
        } else {
            let pivot = refs(begin);
            let m = begin + partition_refs(&refs(begin + 1) as &mut [i32], n - 1, @ |i| cmp(pivot, i));
            swap_i32(&mut refs(m), &mut refs(begin));
            // Process smallest first to minimize stack space
            if m - begin > end - m + 1 {
                stack(++stack_ptr) = (begin, m);
                stack(++stack_ptr) = (m + 1, end);
            } else {
                stack(++stack_ptr) = (m + 1, end);
                stack(++stack_ptr) = (begin, m);
            }
        }
    }
}

fn @max_bvh_size(num_refs: i32) -> (i32, i32) {
    // The upper bound for a binary tree is also an upper bound for larger arities
    (num_refs / 2 + 1, num_refs)
}

fn @make_multi_node(arity: i32) -> MultiNode {
    // Only supports arities 2, 4, and 8
    let mut bboxes2    : [BBox * 2];
    let mut ref_begin2 : [i32 * 2];
    let mut ref_end2   : [i32 * 2];
    let mut cost2      : [f32 * 2];
    let mut tested2    : [bool * 2];

    let mut bboxes4    : [BBox * 4];
    let mut ref_begin4 : [i32 * 4];
    let mut ref_end4   : [i32 * 4];
    let mut cost4      : [f32 * 4];
    let mut tested4    : [bool * 4];

    let mut bboxes8    : [BBox * 8];
    let mut ref_begin8 : [i32 * 8];
    let mut ref_end8   : [i32 * 8];
    let mut cost8      : [f32 * 8];
    let mut tested8    : [bool * 8];

    let (bboxes, ref_begin, ref_end, cost, tested) = match arity {
        2 => (&mut bboxes2 as &mut [BBox], &mut ref_begin2 as &mut [i32], &mut ref_end2 as &mut [i32], &mut cost2 as &mut [f32], &mut tested2 as &mut [bool]),
        4 => (&mut bboxes4 as &mut [BBox], &mut ref_begin4 as &mut [i32], &mut ref_end4 as &mut [i32], &mut cost4 as &mut [f32], &mut tested4 as &mut [bool]),
        _ => (&mut bboxes8 as &mut [BBox], &mut ref_begin8 as &mut [i32], &mut ref_end8 as &mut [i32], &mut cost8 as &mut [f32], &mut tested8 as &mut [bool]),
    };

    let compute_cost = @ |i| { cost(i) = bbox_half_area(bboxes(i)) * ((ref_end(i) - ref_begin(i)) as f32) };
    let mut size = 0;

    MultiNode {
        has_available: @ || {
            if size == 0 || size == arity {
                return(false)
            }
            for i in range(0, size) {
                if !tested(i) {
                    return(true)
                }
            }
            false
        },
        get_available: @ || {
            for i in range(0, size) {
                if !tested(i) {
                    return(i)
                }
            }
            -1
        },
        split: @ |i, split, left, right| {
            ref_begin(size) = split;
            ref_end(size)   = ref_end(i);
            ref_end(i)      = split;
            bboxes(i)       = left;
            bboxes(size)    = right;
            tested(i)       = false;
            tested(size)    = false;
            compute_cost(size);
            compute_cost(i);
            size++;
        },
        insert: @ |begin, end, bbox| {
            ref_begin(size) = begin;
            ref_end(size)   = end;
            bboxes(size)    = bbox;
            tested(size)    = false;
            compute_cost(size);
            size++;
        },
        set_tested: @ |i| tested(i) = true,
        is_tested: @ |i| tested(i),
        sort_by_cost: @ || {
            for i in range(1, size) {
                let (c, b, e, bb, t) = (cost(i), ref_begin(i), ref_end(i), bboxes(i), tested(i));
                let mut j = i;
                while j > 0 && c > cost(j - 1) {
                    cost(j)      = cost(j - 1);
                    ref_begin(j) = ref_begin(j - 1);
                    ref_end(j)   = ref_end(j - 1);
                    bboxes(j)    = bboxes(j - 1);
                    tested(j)    = tested(j - 1);
                    j--;
                }
                cost(j) = c;
                ref_begin(j) = b;
                ref_end(j) = e;
                bboxes(j) = bb;
                tested(j) = t;
            }
        },
        ref_range: @ |i| (ref_begin(i), ref_end(i)),
        bbox: @ |i| bboxes(i),
        cost: @ |i| cost(i),
        size: @ || size
    }
}

fn @build_bvh( write_node: NodeWriter
             , write_leaf: LeafWriter
             , link_nodes: NodeLinker
             , bboxes: fn (i32) -> BBox
             , centers: fn (i32) -> Vec3
             , arity: i32
             , leaf_size: i32
             , leaf_threshold: i32
             , num_refs: i32
             ) -> (i32, i32) {
    let refs = [
        runtime_alloc(0, (sizeof[i32]() * num_refs) as i64) as &mut [i32],
        runtime_alloc(0, (sizeof[i32]() * num_refs) as i64)as &mut [i32],
        runtime_alloc(0, (sizeof[i32]() * num_refs) as i64)as &mut [i32]
    ];
    let tmp_refs = runtime_alloc(0, (sizeof[i32]() * num_refs) as i64) as &mut [i32];
    let flags    = runtime_alloc(0, (sizeof[i8 ]() * num_refs) as i64) as &mut [i8];
    let costs    = runtime_alloc(0, (sizeof[f32]() * num_refs) as i64) as &mut [f32];

    // Sort references according to their center
    for i in parallel(3, 0, 3) {
        let ref_ptr = refs(i);
        for j in range(0, num_refs) { ref_ptr(j) = j; }
        match i {
            0 => sort_refs(ref_ptr, 0, num_refs, @ |i, j| { centers(i).x < centers(j).x }),
            1 => sort_refs(ref_ptr, 0, num_refs, @ |i, j| { centers(i).y < centers(j).y }),
            _ => sort_refs(ref_ptr, 0, num_refs, @ |i, j| { centers(i).z < centers(j).z }),
        }
    }

    let mut global_bbox = empty_bbox();
    for i in range(0, num_refs) {
        global_bbox = bbox_extend(global_bbox, bboxes(i));
    }

    let mut node_count = 0;
    let mut leaf_count = 0;

    let stack_capacity = 64;
    let mut stack : [(i32, i32, i32, BBox) * 64];
    let mut stack_ptr = 0;

    fn @find_split(refs: &[i32], begin: i32, end: i32) -> (i32, f32, BBox) {
        let mut cur_bbox = empty_bbox();

        // Sweep from the left and compute costs
        for i in range(begin, end - 1) {
            cur_bbox = bbox_extend(cur_bbox, bboxes(refs(i)));
            costs(i) = ((i - begin + 1) as f32) * bbox_half_area(cur_bbox);
        }

        let mut min_cost = flt_max;
        let mut min_split = -1;
        let mut min_bbox = empty_bbox();

        cur_bbox = empty_bbox();

        // Sweep from the right and find the minimum cost
        for i in range_rev(end - 1, begin) {
            cur_bbox = bbox_extend(cur_bbox, bboxes(refs(i)));

            let cost = costs(i - 1) + ((end - i) as f32) * bbox_half_area(cur_bbox);
            if cost < min_cost {
                min_bbox  = cur_bbox;
                min_cost  = cost;
                min_split = i;
            }
        }

        (min_split, min_cost, min_bbox)
    }

    fn @build_node(mut parent: i32, begin: i32, end: i32, bbox: BBox) -> () {
        let multi_node = make_multi_node(arity);
        multi_node.insert(begin, end, bbox);

        while multi_node.has_available() {
            let index = multi_node.get_available();
            let (begin, end) = multi_node.ref_range(index);
            let ref_count = end - begin;

            if ref_count <= leaf_threshold {
                multi_node.set_tested(index);
                continue()
            }

            // Try to split the node
            let mut min_axis  = -1;
            let mut min_cost  = flt_max;
            let mut min_split = -1;
            let mut right_bbox;
            for axis in range(0, 3) {
                let (split, cost, bbox) = find_split(refs(axis), begin, end);
                if min_cost > cost {
                    min_cost   = cost;
                    min_split  = split;
                    min_axis   = axis;
                    right_bbox = bbox;
                }
            }

            if min_cost >= multi_node.cost(index) || min_split == begin || min_split == end {
                multi_node.set_tested(index);
                continue()
            }

            let axis1 = (min_axis + 1) % 3;
            let axis2 = (min_axis + 2) % 3;
            mark_split_refs(refs(min_axis), flags, begin, min_split, end);
            split_refs(tmp_refs, refs(axis1), flags, begin, min_split, end);
            split_refs(tmp_refs, refs(axis2), flags, begin, min_split, end);

            // Compute bounding box for left side
            let mut left_bbox = empty_bbox();
            for i in range(begin, min_split) {
                left_bbox = bbox_extend(left_bbox, bboxes(refs(min_axis)(i)));
            }

            multi_node.split(index, min_split, left_bbox, right_bbox);
            multi_node.sort_by_cost();
        }

        fn @make_leaf(i: i32) -> () {
            let (begin, end) = multi_node.ref_range(i);
            let leaf_id = leaf_count;
            leaf_count += (end - begin) / leaf_size;
            write_leaf(leaf_id, end - begin, @ |i| refs(0)(begin + i));
            link_nodes(true, parent / arity, parent % arity, leaf_id);
        }

        fn @push_node(i: i32, node_id: i32) -> () {
            let (begin, end) = multi_node.ref_range(i);
            stack(++stack_ptr) = (node_id * arity + i, begin, end, multi_node.bbox(i));
        }

        if multi_node.size() == 1 {
            // If there is no parent inner node, then generate a dummy one
            if parent == -1 {
                write_node(0, 1, @ |i| multi_node.bbox(0));
                parent = 0;
            }
            make_leaf(0)
        } else {
            let node_id = node_count++;
            write_node(node_id, multi_node.size(), @ |i| multi_node.bbox(i));
            if parent != -1 { link_nodes(false, parent / arity, parent % arity, node_id); }
            // Nodes are sorted by increasing SAH cost, so we push smaller nodes last
            for i in range(0, multi_node.size()) {
                if multi_node.is_tested(i) || stack_ptr >= stack_capacity - 1 {
                    make_leaf(i)
                } else {
                    push_node(i, node_id)
                }
            }
        }
    }

    stack(0) = (-1, 0, num_refs, global_bbox);
    while stack_ptr >= 0 {
        let (parent, begin, end, bbox) = stack(stack_ptr--);
        build_node(parent, begin, end, bbox);
    }

    runtime_release(0, flags);
    for i in unroll(0, 3) {
        runtime_release(0, refs(i) as &mut [i8]);
    }
    runtime_release(0, tmp_refs as &mut [i8]);
    runtime_release(0, costs as &mut [i8]);

    (node_count, leaf_count)
}

fn @build_tri_mesh_bvh( tri_mesh: TriMesh
                      , write_node: NodeWriter
                      , write_leaf: LeafWriter
                      , link_nodes: NodeLinker
                      , arity: i32
                      , tri_size: i32
                      ) -> (i32, i32) {
    let bboxes  = runtime_alloc(0, (sizeof[BBox]() * tri_mesh.num_tris) as i64) as &mut [BBox];
    let centers = runtime_alloc(0, (sizeof[Vec3]() * tri_mesh.num_tris) as i64) as &mut [Vec3];

    // Compute the bounding boxes of each triangle once and store them
    for i in parallel(0, 0, tri_mesh.num_tris) {
        let (i0, i1, i2) = tri_mesh.triangles(i);
        let (v0, v1, v2) = (tri_mesh.vertices(i0), tri_mesh.vertices(i1), tri_mesh.vertices(i2));
        centers(i) = vec3_mulf(vec3_add(vec3_add(v0, v1), v2), 1.0f / 3.0f);
        bboxes(i)  = bbox_append(bbox_append(make_bbox(v0, v0), v1), v2);
    }

    let (node_count, leaf_count) = build_bvh(write_node, write_leaf, link_nodes, @ |i| bboxes(i), @ |i| centers(i), arity, tri_size, tri_size, tri_mesh.num_tris);

    runtime_release(0, bboxes  as &mut [i8]);
    runtime_release(0, centers as &mut [i8]);

    (node_count, leaf_count)
}
