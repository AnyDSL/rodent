// Structure containing the mapping of the traversal algorithm for a particular device.
struct TraversalMapping {
    intrinsics:         Intrinsics,
    ray_box_intrinsics: RayBoxIntrinsics,
    ray_box_ordered:    bool,

    iterate_children:   fn (NodeRef, float, Stack, fn (BBox, fn (float, float) -> ()) -> ()) -> (),
    iterate_primitives: fn (NodeRef, float, fn (Intersector) -> ()) -> (),
    iterate_instances:  fn (NodeRef, float, fn (Instance) -> ()) -> ()
}

type HitCallback  = fn (Hit, fn () -> !, fn (Hit) -> !) -> !;
type Transparency = fn (Hit) -> bool;

// Structure containing the configuration of the traversal algorithm for a particular use case.
struct TraversalConfig {
    hit_callback: HitCallback,
    transparency: Transparency
}

// Instance of an object in the scene
struct Instance {
    id:       int,     // Instance identifier
    inverse:  Mat3x4,  // Inverse matrix

    // Associated traversal algorithm for the object
    traverse: fn (Ray) -> Hit
}

static any_hit : HitCallback = |hit, continue, terminate| -> ! { if any(hit.prim_id < 0) { @continue() } else { @terminate(hit) } };
static closest_hit : HitCallback = |_, continue, _| -> ! @{ continue() };
static opaque : Transparency = |_| @{ false };

fn make_hit(inst_id: int, prim_id: int, t: float, uv: Vec2) -> Hit {
    Hit {
        distance:  t,
        uv_coords: uv,
        prim_id:   prim_id,
        inst_id:   inst_id
    }
}

fn traverse_bvh(mapping: TraversalMapping, config: TraversalConfig, stack: Stack, ray: Ray) -> Hit @{
    let mut inst_id = -1;
    let mut prim_id = -1;
    let mut t = ray.tmax;
    let mut uv = make_vec2(0.0f, 0.0f);

    // The traversal loop should not be unrolled
    while !$stack.is_empty() @{
        // Intersect the bounding box of every child of this node
        for bbox, hit in @mapping.iterate_children(stack.top(), t, stack) {
            @intersect_ray_box(mapping.ray_box_intrinsics, mapping.ray_box_ordered, clip_ray(ray, ray.tmin, t), bbox, hit);
        }

        // Process leaves
        while unlikely($is_leaf(stack.top())) @{
            let leaf = stack.top();

            // Process primitives, if any
            for intersector in @mapping.iterate_primitives(leaf, t) @{
                with hit in intersector(mapping.intrinsics, clip_ray(ray, ray.tmin, t)) @{
                    if !@config.transparency(hit) @{
                        prim_id = hit.prim_id;
                        t  = hit.distance;
                        uv = hit.uv_coords;
                    }
                }

                @config.hit_callback(@make_hit(inst_id, prim_id, t, uv), continue, return)
            }

            // Process instances, if any
            for inst in @mapping.iterate_instances(leaf, t) @{
                let new_dir = mat3x4_mul(inst.inverse, vec3_to_4(ray.dir, 0.0f));
                let new_org = mat3x4_mul(inst.inverse, vec3_to_4(ray.org, 0.0f));
                let hit = inst.traverse(make_ray(new_org, new_dir, ray.tmin, t));
                if hit.prim_id >= 0 @{
                    inst_id = inst.id;
                    prim_id = hit.prim_id;
                    t  = hit.distance;
                    uv = hit.uv_coords;
                }

                @config.hit_callback(@make_hit(inst_id, prim_id, t, uv), continue, return)
            }

            stack.pop()
        }
    }

    return(make_hit(inst_id, prim_id, t, uv))
}
