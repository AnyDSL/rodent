// Structure containing the mapping of the traversal algorithm
// for a particular device and/or use case.
struct TraversalMapping {
    iterate_children:   fn (NodeRef, float, Stack, fn (BBox, fn (float, float) -> ()) -> ()) -> (),
    iterate_primitives: fn (NodeRef, float, fn (Primitive) -> ()) -> (),
    iterate_instances:  fn (NodeRef, float, fn (Instance) -> ()) -> (),
    hit_callback: fn (TraversalResult, fn () -> !, fn (TraversalResult) -> !) -> !,
    transparency: fn (int, Hit) -> bool,
    is_leaf: fn (NodeRef) -> bool,
    intrinsics: Intrinsics,
    ray_box_intrinsics: RayBoxIntrinsics
}

// Result of a call to the traversal algorithm
struct TraversalResult {
    hit: Hit,                   // Hit information
    prim_id: fn () -> int,      // Primitive identifier, or -1 (no intersection found)
    inst_id: fn () -> int       // Instance identifier, or -1 (no instance found)
}

// Instance of an object in the scene
struct Instance {
    id:       fn () -> int,     // Instance identifier
    inverse:  fn () -> Mat3x4,  // Inverse matrix

    // Associated traversal algorithm for the object
    traverse: fn (Ray, float, float) -> TraversalResult
}

struct Ray {
    org:     fn () -> Vec3,     // Origin of the ray
    dir:     fn () -> Vec3,     // Direction of the ray
    inv_dir: fn () -> Vec3,     // Inverse of the direction
    inv_org: fn () -> Vec3      // Origin multiplied by the inverse of the direction
}

type RayStream = fn (int) -> (Ray, float, float);
type HitStream = fn (int, TraversalResult) -> ();

fn make_ray(org: Vec3, dir: Vec3) -> Ray {
    let inv_dir = vec3(safe_rcp(dir.x), safe_rcp(dir.y), safe_rcp(dir.z));
    let inv_org = vec3_mul(org, inv_dir);
    Ray {
        org: || org,
        dir: || dir,
        inv_dir: || inv_dir,
        inv_org: || inv_org
    }
}

fn traverse_bvh(mapping: TraversalMapping, stack: Stack, ray: Ray, tmin: float, tmax: float) -> TraversalResult {
    let mut inst_id = -1;
    let mut prim_id = -1;
    let mut t = tmax;
    let mut n = vec3(0.0f, 0.0f, 0.0f);
    let mut uv = vec2(0.0f, 0.0f);

    fn hit() -> TraversalResult {
        TraversalResult {
            hit: Hit {
                distance:  || t,
                normal:    || n,
                uv_coords: || uv
            },
            prim_id: || prim_id,
            inst_id: || inst_id
        }
    }

    // The traversal loop should not be unrolled
    while !$stack.is_empty() @{
        let node = stack.top();

        // Intersect the bounding box of every child of this node
        for bbox, hit in mapping.iterate_children(node, t, stack) @{
            intersect_ray_box(mapping.ray_box_intrinsics, ray, bbox, tmin, t, hit);
        }

        // Process leaves
        while $mapping.is_leaf(stack.top()) @{
            let leaf = stack.top();

            // Process primitives, if any
            for prim in mapping.iterate_primitives(leaf, t) @{
                with hit in prim.intersect(mapping.intrinsics, ray, tmin, t) @{
                    if !mapping.transparency(prim.id(), hit) @{
                        prim_id = prim.id();
                        t = hit.distance();
                        n = hit.normal();
                        uv = hit.uv_coords();
                    }
                }

                mapping.hit_callback(hit(), continue, return)
            }

            // Process instances, if any
            for inst in mapping.iterate_instances(leaf, t) @{
                let new_dir = mat3x4_mul(inst.inverse(), vec3_to_4(ray.dir(), 0.0f));
                let new_org = mat3x4_mul(inst.inverse(), vec3_to_4(ray.org(), 0.0f));
                let result = inst.traverse(make_ray(new_org, new_dir), tmin, t);
                if result.prim_id() >= 0 @{
                    inst_id = inst.id();
                    prim_id = result.prim_id();
                    t = result.hit.distance();
                    n = result.hit.normal();
                    uv = result.hit.uv_coords();
                }
            }

            stack.pop()
        }
    }

    hit()
}
