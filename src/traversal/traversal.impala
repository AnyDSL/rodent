type EarlyExitFn         = fn () -> !;
type IterateChildrenFn   = fn (Stack, &mut Ray, &mut Hit, fn (BBox) -> (bool, float, float)) -> ();
type IteratePrimitivesFn = fn (NodeRef, &Ray, &Hit, EarlyExitFn, fn (Intersector) -> ()) -> ();

// Structure containing the mapping of the traversal algorithm for a particular device.
struct TraversalMapping {
    ray_box_intrinsics: RayBoxIntrinsics,
    ray_box_ordered:    bool,

    iterate_children:   IterateChildrenFn,
    iterate_primitives: IteratePrimitivesFn,
}

fn @traverse_bvh(mapping: TraversalMapping, stack: Stack, mut ray: Ray) -> Hit {
    let mut hit = empty_hit(ray.tmax);
    let early_exit = || -> ! return(hit);

    // The traversal loop should not be unrolled
    while !stack.is_empty() {
        // Intersect the bounding box of every child of the current node
        // This may require to update the current traversal result
        for bbox in mapping.iterate_children(stack, &mut ray, &mut hit) @{
            intersect_ray_box(mapping.ray_box_intrinsics, mapping.ray_box_ordered, ray, bbox)
        }

        // Process leaves
        while unlikely(is_leaf(stack.top())) {
            // Process primitives, if any
            with intersector in mapping.iterate_primitives(stack.top(), &ray, &hit, early_exit) {
                with intr in intersector(ray) {
                    hit.prim_id   = intr.prim_id;
                    hit.distance  = intr.distance;
                    hit.uv_coords = intr.uv_coords;
                    ray.tmax      = intr.distance;
                }
            }

            stack.pop()
        }
    }

    hit
}
