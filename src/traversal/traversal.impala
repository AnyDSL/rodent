struct TraversalMapping {
    iterate_children:   fn (NodeRef, float, Stack, fn (BBox, fn (float, float) -> ()) -> ()) -> (),
    iterate_primitives: fn (NodeRef, float, fn (Primitive) -> ()) -> (),
    iterate_instances:  fn (NodeRef, float, fn (Instance) -> ()) -> (),
    hit_callback: fn (Hit, fn () -> !, fn () -> !) -> !,
    is_leaf: fn (NodeRef) -> bool,
    intrinsics: Intrinsics,
    ray_box_intrinsics: RayBoxIntrinsics
}

struct TraversalResult {
    hit: Hit,
    prim_id: fn () -> int,
    inst_id: fn () -> int
}

struct Instance {
    id:       fn () -> int,
    inverse:  fn () -> Mat3x4,
    traverse: fn (Ray, float, float) -> TraversalResult
}

struct Ray {
    org:     fn () -> Vec3,
    dir:     fn () -> Vec3,
    inv_dir: fn () -> Vec3,
    inv_org: fn () -> Vec3
}

type RayStream = fn (int) -> (Ray, float, float);
type HitStream = fn (int, TraversalResult) -> ();

fn make_ray(org: Vec3, dir: Vec3) -> Ray {
    let inv_dir = vec3(safe_rcp(dir.x), safe_rcp(dir.y), safe_rcp(dir.z));
    let inv_org = vec3_mul(org, inv_dir);
    Ray {
        org: || org,
        dir: || dir,
        inv_dir: || inv_dir,
        inv_org: || inv_org
    }
}

fn traverse_bvh(mapping: TraversalMapping, stack: Stack, ray: Ray, tmin: float, tmax: float) -> TraversalResult {
    let mut inst_id = -1;
    let mut prim_id = -1;
    let mut t = tmax;
    let mut n = vec3(0.0f, 0.0f, 0.0f);
    let mut uv = vec2(0.0f, 0.0f);

    fn exit() -> ! {
        return (TraversalResult {
            hit: Hit {
                distance:  || t,
                normal:    || n,
                uv_coords: || uv
            },
            prim_id: || prim_id,
            inst_id: || inst_id
        })
    }

    // The traversal loop should not be unrolled
    while !$stack.is_empty() @{
        let node = stack.top();

        // Intersect the bounding box of every child of this node
        for bbox, hit in mapping.iterate_children(node, t, stack) {
            intersect_ray_box(mapping.ray_box_intrinsics, ray, bbox, tmin, t, hit);
        }

        // Process leaves
        while mapping.is_leaf(stack.top()) {
            let leaf = stack.top();

            // Process primitives, if any
            for prim in mapping.iterate_primitives(leaf, t) {
                with hit in prim.intersect(mapping.intrinsics, ray, tmin, t) {
                    prim_id = prim.id();
                    t = hit.distance();
                    n = hit.normal();
                    uv = hit.uv_coords();
                    mapping.hit_callback(hit, break, exit)
                }
            }

            // Process instances, if any
            for inst in mapping.iterate_instances(leaf, t) {
                let new_dir = mat3x4_mul(inst.inverse(), vec3_to_4(ray.dir(), 0.0f));
                let new_org = mat3x4_mul(inst.inverse(), vec3_to_4(ray.org(), 0.0f));
                let result = inst.traverse(make_ray(new_org, new_dir), tmin, t);
                if result.prim_id() >= 0 {
                    inst_id = inst.id();
                    prim_id = result.prim_id();
                    t = result.hit.distance();
                    n = result.hit.normal();
                    uv = result.hit.uv_coords();
                }
            }

            stack.pop()
        }
    }

    exit()
}
