// Structure containing the mapping of the traversal algorithm
// for a particular device and/or use case.
struct TraversalMapping {
    intrinsics:         Intrinsics,
    ray_box_intrinsics: RayBoxIntrinsics,

    iterate_children:   fn (NodeRef, float, Stack, fn (BBox, fn (float, float) -> ()) -> ()) -> (),
    iterate_primitives: fn (NodeRef, float, fn (Primitive) -> ()) -> (),
    iterate_instances:  fn (NodeRef, float, fn (Instance) -> ()) -> (),

    hit_callback: fn (TraversalResult, fn () -> !, fn (TraversalResult) -> !) -> !,
    transparency: fn (int, Hit) -> bool,
    is_leaf:      fn (NodeRef) -> bool
}

// Result of a call to the traversal algorithm
struct TraversalResult {
    hit: Hit,                   // Hit information
    prim_id: fn () -> int,      // Primitive identifier, or -1 (no intersection found)
    inst_id: fn () -> int       // Instance identifier, or -1 (no instance found)
}

// Instance of an object in the scene
struct Instance {
    id:       fn () -> int,     // Instance identifier
    inverse:  fn () -> Mat3x4,  // Inverse matrix

    // Associated traversal algorithm for the object
    traverse: fn (Ray, float, float) -> TraversalResult
}

type RayStream = fn (int) -> (Ray, float, float);
type HitStream = fn (int, TraversalResult) -> ();

fn traverse_bvh(mapping: TraversalMapping, stack: Stack, ray: Ray, tmin: float, tmax: float) -> TraversalResult @{
    let mut inst_id = -1;
    let mut prim_id = -1;
    let mut t = tmax;
    let mut n = make_vec3(0.0f, 0.0f, 0.0f);
    let mut uv = make_vec2(0.0f, 0.0f);

    let make_result = || {
        TraversalResult {
            hit: Hit {
                distance:  || t,
                normal:    || n,
                uv_coords: || uv
            },
            prim_id: || prim_id,
            inst_id: || inst_id
        }
    };

    // The traversal loop should not be unrolled
    while !$stack.is_empty() @{
        let node = stack.top();

        // Intersect the bounding box of every child of this node
        for bbox, hit in mapping.iterate_children(node, t, stack) @{
            intersect_ray_box(mapping.ray_box_intrinsics, ray, bbox, tmin, t, hit);
        }

        // Process leaves
        while $mapping.is_leaf(stack.top()) @{
            let leaf = stack.top();

            // Process primitives, if any
            for prim in @mapping.iterate_primitives(leaf, t) {
                with hit in prim.intersect(mapping.intrinsics, ray, tmin, t) {
                    if !@mapping.transparency(prim.id(), hit) {
                        prim_id = prim.id();
                        t = hit.distance();
                        n = hit.normal();
                        uv = hit.uv_coords();
                    }
                }

                @mapping.hit_callback(make_result(), continue, return)
            }

            // Process instances, if any
            for inst in @mapping.iterate_instances(leaf, t) {
                let new_dir = mat3x4_mul(inst.inverse(), vec3_to_4(ray.dir(), 0.0f));
                let new_org = mat3x4_mul(inst.inverse(), vec3_to_4(ray.org(), 0.0f));
                let result = inst.traverse(make_ray(new_org, new_dir), tmin, t);
                if result.prim_id() >= 0 @{
                    inst_id = inst.id();
                    prim_id = result.prim_id();
                    t = result.hit.distance();
                    n = result.hit.normal();
                    uv = result.hit.uv_coords();
                }
            }

            stack.pop()
        }
    }

    return(make_result())
}
