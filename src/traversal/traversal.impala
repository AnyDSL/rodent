// Structure containing the mapping of the traversal algorithm for a particular device.
struct TraversalMapping {
    intrinsics:         Intrinsics,
    ray_box_intrinsics: RayBoxIntrinsics,
    ray_box_ordered:    bool,

    iterate_children:   fn (Stack, float, fn (BBox) -> (bool, float, float)) -> (),
    iterate_primitives: fn (NodeRef, float, fn (Intersector) -> ()) -> (),
}

// Structure containing the configuration of the traversal algorithm for a particular use case.
struct TraversalConfig {
    any_hit: bool
}

fn traverse_bvh(mapping: TraversalMapping, config: TraversalConfig, stack: Stack, ray: Ray) -> Hit @{
    let mut res = make_hit(-1, -1, ray.tmax, undef());

    // The traversal loop should not be unrolled
    while !$stack.is_empty() @{
        // Intersect the bounding box of every child of the current node
        for bbox in @mapping.iterate_children(stack, res.distance) {
            @intersect_ray_box(mapping.ray_box_intrinsics,
                               mapping.ray_box_ordered,
                               clip_ray(ray, ray.tmin, res.distance),
                               bbox)
        }

        // Process leaves
        while unlikely(is_leaf(stack.top())) @{
            // Process primitives, if any
            for intersector in @mapping.iterate_primitives(stack.top(), res.distance) @{
                with hit in @intersector(mapping.intrinsics, clip_ray(ray, ray.tmin, res.distance)) @{
                    res.prim_id   = hit.prim_id;
                    res.distance  = hit.distance;
                    res.uv_coords = hit.uv_coords;
                }

                if config.any_hit && all(res.prim_id >= 0) { return(res) }
            }

            stack.pop()
        }
    }

    res
}
