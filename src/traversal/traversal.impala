struct TraversalMapping {
    iterate_children:   fn (NodeRef, float, Stack, fn (BBox, fn (float, float) -> ()) -> ()) -> (),
    iterate_primitives: fn (NodeRef, float, fn (Intersector, int) -> ()) -> (),
    hit_callback: fn (Hit, fn () -> !, fn () -> !) -> !,
    is_leaf: fn (NodeRef) -> bool,
    intrinsics: Intrinsics,
    ray_box_intrinsics: RayBoxIntrinsics
}

struct TraversalResult {
    hit: Hit,
    prim_id: fn () -> int,
    inst_id: fn () -> int
}

type RayStream = fn (int) -> (Ray, float, float);
type HitStream = fn (int, TraversalResult) -> ();

fn traverse_bvh(mapping: TraversalMapping, stack: Stack, ray: Ray, tmin: float, tmax: float) -> TraversalResult {
    let mut prim_id = -1;
    let mut t = tmax;
    let mut n = vec3(0.0f, 0.0f, 0.0f);
    let mut uv = vec2(0.0f, 0.0f);

    fn exit() -> ! {
        return (TraversalResult {
            hit: Hit {
                distance:  || t,
                normal:    || n,
                uv_coords: || uv
            },
            prim_id: || prim_id,
            inst_id: || -1
        })
    }

    // The traversal loop should not be unrolled
    while !$stack.is_empty() @{
        let node = stack.top();
        for bbox, hit in mapping.iterate_children(node, t, stack) {
            intersect_ray_box(mapping.ray_box_intrinsics, ray, bbox, tmin, t, hit);
        }

        while mapping.is_leaf(stack.top()) {
            let leaf = stack.top();

            for intersector, id in mapping.iterate_primitives(leaf, t) {
                with hit in intersector(mapping.intrinsics, ray, tmin, t) {
                    prim_id = id;
                    t = hit.distance();
                    n = hit.normal();
                    uv = hit.uv_coords();
                    mapping.hit_callback(hit, break, exit)
                }
            }

            stack.pop()
        }
    }

    exit()
}
