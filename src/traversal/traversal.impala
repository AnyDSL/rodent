// Structure containing the mapping of the traversal algorithm for a particular device.
struct TraversalMapping {
    intrinsics:         Intrinsics,
    ray_box_intrinsics: RayBoxIntrinsics,
    ray_box_ordered:    bool,

    enter_sublevel:     fn (Stack, Ray, fn (Hit) -> ()) -> (),

    iterate_children:   fn (NodeRef, float, Stack, fn (BBox) -> (bool, float, float)) -> (),
    iterate_primitives: fn (NodeRef, float, fn (Intersector) -> ()) -> (),
}

type HitCallback  = fn (Hit, fn () -> !, fn (Hit) -> !) -> !;
type Transparency = fn (Hit) -> bool;

// Structure containing the configuration of the traversal algorithm for a particular use case.
struct TraversalConfig {
    hit_callback: HitCallback,
    transparency: Transparency
}

// Abstract definition of a BVH
struct Bvh {
    node:  fn (int) -> BvhNode,
    tri:   fn (int) -> BvhTri,
    arity: int
}

struct BvhNode {
    bbox:     fn (int, int) -> BBox,    // Loads the bounding box of one child node (octant as second argument, -1 if no octant)
    child:    fn (int) -> int,          // Gets the index of one child node
    prefetch: fn () -> ()               // Prefetches this node
}

struct BvhTri {
    load: fn (int) -> Tri,              // Loads the given triangle in the packet
    id:   fn (int) -> int,              // Identifier of the given triangle in the packet
    size: int                           // Number of triangles in the packet
}

static any_hit : HitCallback = |hit, continue, terminate| -> ! { if any(hit.prim_id < 0) { @continue() } else { @terminate(hit) } };
static closest_hit : HitCallback = |_, continue, _| -> ! @{ continue() };
static opaque : Transparency = |_| @{ false };
static no_sublevel = |_, _, _| ();

fn make_hit(inst_id: int, prim_id: int, t: float, uv: Vec2) -> Hit {
    Hit {
        distance:  t,
        uv_coords: uv,
        prim_id:   prim_id,
        inst_id:   inst_id
    }
}

fn traverse_bvh(mapping: TraversalMapping, config: TraversalConfig, stack: Stack, ray: Ray) -> Hit @{
    let mut inst_id = -1;
    let mut prim_id = -1;
    let mut t = ray.tmax;
    let mut uv = make_vec2(0.0f, 0.0f);

    // The traversal loop should not be unrolled
    while !$stack.is_empty() @{
        // If the BVH has different levels, handle them here
        with hit in @mapping.enter_sublevel(stack, clip_ray(ray, ray.tmin, t)) @{
            inst_id = hit.inst_id;
            prim_id = hit.prim_id;
            t  = hit.distance;
            uv = hit.uv_coords;
        }

        // Intersect the bounding box of every child of the current node
        for bbox in @mapping.iterate_children(stack.top(), t, stack) {
            @intersect_ray_box(mapping.ray_box_intrinsics, mapping.ray_box_ordered, clip_ray(ray, ray.tmin, t), bbox)
        }

        // Process leaves
        while unlikely($is_leaf(stack.top())) @{
            // Process primitives, if any
            for intersector in @mapping.iterate_primitives(stack.top(), t) @{
                with hit in @intersector(mapping.intrinsics, clip_ray(ray, ray.tmin, t)) @{
                    if !@config.transparency(hit) @{
                        prim_id = hit.prim_id;
                        t  = hit.distance;
                        uv = hit.uv_coords;
                    }
                }
                @config.hit_callback(@make_hit(inst_id, prim_id, t, uv), continue, return)
            }

            stack.pop()
        }
    }

    make_hit(inst_id, prim_id, t, uv)
}
