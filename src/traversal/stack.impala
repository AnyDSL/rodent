struct NodeRef {
    node: int,
    tmin: float
}

struct Stack {
    push:       fn (int, float) -> (),
    push_after: fn (int, float) -> (),
    set_top:    fn (int, float) -> (),
    sort_n:     fn (int, fn (float, float) -> bool, SortingNetwork, bool) -> (),
    pop:        fn () -> (),
    top:        fn () -> NodeRef,
    is_empty:   fn () -> bool,
    size:       fn () -> int
}

struct SmallStack {
    write: fn (int, (int, float)) -> (),
    read:  fn (int) -> (int, float)
}

fn @(true) is_leaf (ref: NodeRef) -> bool { ref.node < 0 }
fn @(true) is_inner(ref: NodeRef) -> bool { ref.node > 0 }

fn @(true) make_small_stack(n: int) -> SmallStack {
    if n == 0 {
        SmallStack {
            write: |_, _| (),
            read: |_| undef[(int, float)]()
        }
    } else {
        let mut val : (int, float);
        let sub = make_small_stack(n - 1);
        SmallStack {
            write: |i, v| {
                if i == n - 1 {
                    val = v;
                } else {
                    sub.write(i, v)
                }
            },
            read: |i| {
                if i == n - 1 {
                    val
                } else {
                    sub.read(i)
                }
            }
        }
    }
}

fn @(true) allocate_stack() -> Stack {
    let mut nodes : [int   * 64];
    let mut tmins : [float * 64];
    let mut node = 0;
    let mut tmin = flt_max;
    let mut ptr = -1;

    let vals_accessor = |off| (|i| nodes(i + off), |i, v| nodes(i + off) = v);
    let keys_accessor = |off| (|i| tmins(i + off), |i, k| tmins(i + off) = k);

    Stack {
        push: |n, t| {
            ptr++;
            nodes(ptr) = node;
            tmins(ptr) = tmin;
            node = n;
            tmin = t;
        },
        push_after: |n, t| {
            ptr++;
            nodes(ptr) = n;
            tmins(ptr) = t;
        },
        set_top: |n, t| {
            node = n;
            tmin = t;
        },
        sort_n: |n, cmp, sorting_network, branchless| {
            let (read_val, write_val) = vals_accessor(ptr - n + 1);
            let (read_key, write_key) = keys_accessor(ptr - n + 1);
            let tmp = make_small_stack(n);

            let cmp_swap = if branchless {
                |i, j| {
                    let (v0, k0) = tmp.read(i);
                    let (v1, k1) = tmp.read(j);
                    let swp = cmp(k0, k1);
                    tmp.write(i, select(swp, (v1, k1), (v0, k0)));
                    tmp.write(j, select(swp, (v0, k0), (v1, k1)));
                }
            } else {
                |i, j| {
                    let (k0, k1) = (read_key(i), read_key(j));
                    if cmp(k0, k1) {
                        let (v0, v1) = (read_val(i), read_val(j));
                        write_key(i, k1);
                        write_key(j, k0);
                        write_val(i, v1);
                        write_val(j, v0);
                    }
                }
            };

            if branchless {
                // Store the stack elements into registers
                for i in range(0, n) {
                    tmp.write(i, (read_val(i), read_key(i)))
                }
            }

            sorting_network(n, cmp_swap);

            if branchless {
                // Read back the stack elements from registers
                for i in range(0, n) {
                    let (v, k) = tmp.read(i);
                    write_val(i, v);
                    write_key(i, k);
                }
            }
        },
        pop: || {
            node = nodes(ptr);
            tmin = tmins(ptr);
            ptr--;
        },
        top: || NodeRef { node: node, tmin: tmin },
        is_empty: || node == 0,
        size: || ptr
    }
}
