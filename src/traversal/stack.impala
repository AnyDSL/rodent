struct NodeRef {
    node: int,
    tmin: float
}

struct Stack {
    push:       fn (int, float) -> (),
    push_after: fn (int, float) -> (),
    set_top:    fn (int, float) -> (),
    sort_n:     fn (int) -> (),
    pop:        fn () -> (),
    top:        fn () -> NodeRef,
    is_empty:   fn () -> bool
}

fn is_leaf (ref: NodeRef) -> bool { ref.node < 0 }
fn is_inner(ref: NodeRef) -> bool { ref.node > 0 }

fn allocate_stack() -> Stack {
    let mut nodes : [int   * 64];
    let mut tmins : [float * 64];
    let mut node = 0;
    let mut tmin = flt_max;
    let mut ptr = -1;

    Stack {
        push: |n, t| {
            ptr++;
            nodes(ptr) = node;
            tmins(ptr) = tmin;
            node = n;
            tmin = t;
        },
        push_after: |n, t| {
            ptr++;
            nodes(ptr) = n;
            tmins(ptr) = t;
        },
        set_top: |n, t| {
            node = n;
            tmin = t;
        },
        sort_n: |n| {
            let cmp_swap = |i, j| {
                let (t0, t1) = (tmins(ptr - i), tmins(ptr - j));
                let (n0, n1) = (nodes(ptr - i), nodes(ptr - j));
                let swap = t0 > t1;
                tmins(ptr - i) = select(swap, t1, t0);
                nodes(ptr - i) = select(swap, n1, n0);
                tmins(ptr - j) = select(swap, t0, t1);
                nodes(ptr - j) = select(swap, n0, n1);
            };
            bose_nelson_sort(n, cmp_swap);
        },
        pop: || {
            node = nodes(ptr);
            tmin = tmins(ptr);
            ptr--;
        },
        top: || NodeRef { node: node, tmin: tmin },
        is_empty: || node == 0
    }
}
