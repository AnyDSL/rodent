struct Bvh2 {
    nodes: &[Bvh2Node],
    tris:  &[Bvh2Tri]
}

struct Bvh2Tri {
    v0: [float * 3],
    nx: float,
    e1: [float * 3],
    ny: float,
    e2: [float * 3],
    id: int
}

struct Bvh2BBox {
    lo_x: float, hi_x: float,
    lo_y: float, hi_y: float,
    lo_z: float, hi_z: float
}

struct Bvh2Node {
    left_bb:  Bvh2BBox,
    right_bb: Bvh2BBox,
    left:  int,
    right: int,
    pad1:  int,
    pad2:  int
}

fn make_ray_box_intrinsics_nvvm() -> RayBoxIntrinsics {
    // Use video instructions to speed-up the ray-box test
    RayBoxIntrinsics {
        fminf: nvvm_fminf,
        fmaxf: nvvm_fmaxf,
        fminminf: |a, b, c| bitcast[float](nvvm_minmin(bitcast[int](a), bitcast[int](b), bitcast[int](c))),
        fmaxmaxf: |a, b, c| bitcast[float](nvvm_maxmax(bitcast[int](a), bitcast[int](b), bitcast[int](c))),
        fminmaxf: |a, b, c| bitcast[float](nvvm_minmax(bitcast[int](a), bitcast[int](b), bitcast[int](c))),
        fmaxminf: |a, b, c| bitcast[float](nvvm_maxmin(bitcast[int](a), bitcast[int](b), bitcast[int](c))),
        fcmp_le: |a, b| a <= b
    }
}

fn make_gpu_ray_layout(rays: &[Ray1AoS], hits: &mut[Hit1AoS]) -> RayLayout {
    RayLayout {
        packet_size: 1,
        input: |i, j| {
            let ray_ptr = &rays(i + j) as &[1][simd[float * 4]];
            let ray0 = nvvm_ldg4_f32(&ray_ptr(0));
            let ray1 = nvvm_ldg4_f32(&ray_ptr(1));
            make_ray(make_vec3(ray0(0), ray0(1), ray0(2)),
                     make_vec3(ray1(0), ray1(1), ray1(2)),
             ray0(3), ray1(3))
        },
        output: |i, j, hit| {
            *(&hits(i + j) as &mut simd[float * 4]) =
                simd[bitcast[float](hit.prim_id), hit.distance, hit.uv_coords.x, hit.uv_coords.y];
        }
    }
}

fn gpu_traverse_bvh2(config: TraversalConfig, bvh: &Bvh2, ray_layout: RayLayout, ray_count: int) -> () {
    let (nodes, tris) = (bvh.nodes, bvh.tris);

    let block_size = 64;
    let grid  = (ray_count, ray_layout.packet_size, 1);
    let block = (block_size, ray_layout.packet_size, 1);
    let acc   = nvvm_accelerator(0);

    with acc.exec(grid, block) @{
        let (i, j) = (acc.tidx() + acc.bidx() * acc.bdimx(), acc.tidy());
        if (i + j) >= ray_count { break() }

        let ray = ray_layout.input(i, j);

        let stack = allocate_stack();
        stack.push(1, 0.0f);

        let mapping = TraversalMapping {
            iterate_children: |node_ref, tmax, stack, body, exit| -> ! {
                let node_ptr = &nodes(node_ref.node - 1) as &[1][simd[float * 4]];
                let bb0 = nvvm_ldg4_f32(&node_ptr(0));
                let bb1 = nvvm_ldg4_f32(&node_ptr(1));
                let bb2 = nvvm_ldg4_f32(&node_ptr(2));
                let mut children = nvvm_ldg4_i32(&node_ptr(3) as &[1]simd[int * 4]);

                let box1 = make_bbox(make_vec3(bb0(0), bb0(2), bb1(0)),
                                     make_vec3(bb0(1), bb0(3), bb1(1)));
                let box2 = make_bbox(make_vec3(bb1(2), bb2(0), bb2(2)),
                                     make_vec3(bb1(3), bb2(1), bb2(3)));

                let intersect_child = |box| -> (bool, float) {
                    body(box, |tentry, _, _| -> ! { return(true, tentry) });
                    (false, 0.0f)
                };

                let (hit1, t1) = @intersect_child(box1);
                let (hit2, t2) = @intersect_child(box2);

                if !hit1 && !hit2 {
                    stack.pop();
                } else {
                    if hit1 && hit2 {
                        if t1 < t2 {
                            let c = children(0);
                            children(0) = children(1);
                            children(1) = c;
                        }
                        stack.push_after(children(0), 0.0f);
                        stack.set_top(children(1), 0.0f);
                    } else {
                        stack.set_top(if hit1 { children(0) } else { children(1) }, 0.0f)
                    }
                }
            },
            iterate_primitives: |leaf_ref, tmax, body, exit| -> ! {
                let mut tri_id = !leaf_ref.node;
                while true {
                    let tri_ptr = &tris(tri_id) as &[1][simd[float * 4]];
                    let tri0 = nvvm_ldg4_f32(&tri_ptr(0));
                    let tri1 = nvvm_ldg4_f32(&tri_ptr(1));
                    let tri2 = nvvm_ldg4_f32(&tri_ptr(2));

                    let id = bitcast[uint](tri2(3));
                    let v0 = make_vec3(tri0(0), tri0(1), tri0(2));
                    let e1 = make_vec3(tri1(0), tri1(1), tri1(2));
                    let e2 = make_vec3(tri2(0), tri2(1), tri2(2));
                    let  n = make_vec3(tri0(3), tri1(3), vec3_cross(e1, e2).z);

                    @body(make_ray_tri_intersector(make_tri(v0, e1, e2, n), (id & 0x7FFFFFFFu) as int));

                    if (id & 0x80000000u) != 0u { break() }
                    tri_id++;
                }
            },
            iterate_instances: |_, _, _| {},
            intrinsics: nvvm_intrinsics,
            ray_box_intrinsics: make_ray_box_intrinsics_nvvm(),
            ray_box_ordered: false
        };

        ray_layout.output(i, j, @traverse_bvh(mapping, config, stack, ray))
    }
}
