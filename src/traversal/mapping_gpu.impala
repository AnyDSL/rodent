struct Bvh2 {
    nodes: &[Bvh2Node],
    tris:  &[Bvh2Tri]
}

struct Bvh2Tri {
    v0: [float * 3],
    nx: float,
    e1: [float * 3],
    ny: float,
    e2: [float * 3],
    id: int
}

struct Bvh2BBox {
    lo_x: float, hi_x: float,
    lo_y: float, hi_y: float,
    lo_z: float, hi_z: float
}

struct Bvh2Node {
    left_bb:  Bvh2BBox,
    right_bb: Bvh2BBox,
    left:  int,
    right: int,
    pad1:  int,
    pad2:  int
}

fn ray_box_intrinsics_nvvm() -> RayBoxIntrinsics {
    RayBoxIntrinsics {
        fminf: nvvm_fminf,
        fmaxf: nvvm_fmaxf,
        fminminf: |a, b, c| bitcast[float](nvvm_minmin(bitcast[int](a), bitcast[int](b), bitcast[int](c))),
        fmaxmaxf: |a, b, c| bitcast[float](nvvm_maxmax(bitcast[int](a), bitcast[int](b), bitcast[int](c))),
        fminmaxf: |a, b, c| bitcast[float](nvvm_minmax(bitcast[int](a), bitcast[int](b), bitcast[int](c))),
        fmaxminf: |a, b, c| bitcast[float](nvvm_maxmin(bitcast[int](a), bitcast[int](b), bitcast[int](c)))
    }
}

fn gpu_traverse_bvh(bvh: &Bvh2, rays: RayStream, hits: HitStream, ray_count: int) -> () {
    let (nodes, tris) = (bvh.nodes, bvh.tris);

    let block_size = 64;
    let grid  = (ray_count, 1, 1);
    let block = (block_size, 1, 1);
    let acc = nvvm_accelerator;

    with acc.exec(acc.dev(), grid, block) @{
        let i = acc.tidx() + acc.bidx() * acc.bdimx();
        if i >= ray_count { break() }

        let (ray, tmin, tmax) = rays(i);

        let stack = alloc_stack();
        stack.push(0, 0.0f);

        let mapping = TraversalMapping {
            iterate_children: |node_ref, tmax, stack, body, exit| -> ! {
                let node_ptr = &nodes(node_ref.node) as &[1][simd[float * 4]];
                let bb0 = nvvm_ldg4_f32(&node_ptr(0));
                let bb1 = nvvm_ldg4_f32(&node_ptr(1));
                let bb2 = nvvm_ldg4_f32(&node_ptr(2));
                let mut children = nvvm_ldg4_i32(&node_ptr(3) as &[1]simd[int * 4]);

                let box1 = make_bbox(vec3(bb0(0), bb0(2), bb1(0)),
                                     vec3(bb0(1), bb0(3), bb1(1)));
                let box2 = make_bbox(vec3(bb1(2), bb2(0), bb2(2)),
                                     vec3(bb1(3), bb2(1), bb2(3)));

                let intersect_child = |box| -> (bool, float) {
                    body(box, |tentry, _, _| -> ! { return(true, tentry) });
                    (false, 0.0f)
                };

                let (hit1, t1) = @intersect_child(box1);
                let (hit2, t2) = @intersect_child(box2);

                if !hit1 && !hit2 {
                    stack.pop();
                } else {
                    if hit1 && hit2 {
                        if t1 < t2 {
                            let c = children(0);
                            children(0) = children(1);
                            children(1) = c;
                        }
                        stack.push_after(children(0), 0.0f);
                        stack.set_top(children(1), 0.0f);
                    } else {
                        stack.set_top(if hit1 { children(0) } else { children(1) }, 0.0f)
                    }
                }
            },
            iterate_primitives: |leaf_ref, tmax, body, exit| -> ! {
                let mut tri_id = !leaf_ref.node / 3;
                while true {
                    let tri_ptr = &tris(tri_id) as &[1][simd[float * 4]];
                    let tri0 = nvvm_ldg4_f32(&tri_ptr(0));
                    let tri1 = nvvm_ldg4_f32(&tri_ptr(1));
                    let tri2 = nvvm_ldg4_f32(&tri_ptr(2));

                    let id = bitcast[int](tri1(3));
                    let v0 = vec3(tri0(0), tri0(1), tri0(2));
                    let v1 = vec3(tri1(0), tri1(1), tri1(2));
                    let v2 = vec3(tri2(0), tri2(1), tri2(2));
                    let e1 = vec3_sub(v0, v1);
                    let e2 = vec3_sub(v2, v0);
                    let  n = vec3_cross(e1, e2);

                    // Breaks compatibility with old traversal tools
                    //let e1 = vec3(tri1(0), tri1(1), tri1(2));
                    //let e2 = vec3(tri2(0), tri2(1), tri2(2));
                    //let  n = vec3(tri0(3), tri1(3), vec3_cross(e1, e2).x);

                    @body(make_primitive(ray_tri_intersector(make_tri(v0, e1, e2, n)), id));

                    if $bitcast[uint](tri2(3)) == 0x80000000u { break() }
                    tri_id++;
                }
            },
            iterate_instances: |_, _, _| {},
            hit_callback: |hit, continue, exit| -> ! continue(),
            is_leaf: |node_ref| node_ref.node < 0,
            intrinsics: nvvm_intrinsics,
            ray_box_intrinsics: ray_box_intrinsics_nvvm()
        };

        hits(i, @traverse_bvh(mapping, stack, ray, tmin, tmax))
    }
}
