// Misc. ---------------------------------------------------------------------------

// Loads a bounding box ordered by octant on the CPU
fn make_gpu_ordered_bbox(bbox: BBox, octant: int) -> BBox {
    let (inv_x, inv_y, inv_z) = ((octant & 1) == 0, (octant & 2) == 0, (octant & 3) == 0);
    make_bbox(
        make_vec3(
            select(inv_x, bbox.max.x, bbox.min.x),
            select(inv_y, bbox.max.y, bbox.min.y),
            select(inv_z, bbox.max.z, bbox.min.z)),
        make_vec3(
            select(inv_x, bbox.min.x, bbox.max.x),
            select(inv_y, bbox.min.y, bbox.max.y),
            select(inv_z, bbox.min.z, bbox.max.z))
    )
}

// BVH2 ----------------------------------------------------------------------------

struct Bvh2 {
    nodes: &[Bvh2Node],
    tris:  &[Bvh2Tri]
}

struct Bvh2Tri {
    v0: [float * 3],
    nx: float,
    e1: [float * 3],
    ny: float,
    e2: [float * 3],
    id: int
}

struct Bvh2BBox {
    lo_x: float, hi_x: float,
    lo_y: float, hi_y: float,
    lo_z: float, hi_z: float
}

struct Bvh2Node {
    left_bb:  Bvh2BBox,
    right_bb: Bvh2BBox,
    left:  int,
    right: int,
    pad1:  int,
    pad2:  int
}

fn make_gpu_bvh2(bvh2: Bvh2) -> Bvh {
    Bvh {
        node: |j| {
            let node_ptr = &bvh2.nodes(j) as &[1][simd[float * 4]];
            let bb0 = nvvm_ldg4_f32(&node_ptr(0));
            let bb1 = nvvm_ldg4_f32(&node_ptr(1));
            let bb2 = nvvm_ldg4_f32(&node_ptr(2));
            let children = nvvm_ldg4_i32(&node_ptr(3) as &[1]simd[int * 4]);

            BvhNode {
                bbox: |i, octant| {
                    let bbox =
                        if i == 0 {
                            make_bbox(make_vec3(bb0(0), bb0(2), bb1(0)),
                                      make_vec3(bb0(1), bb0(3), bb1(1)))
                        } else {
                            make_bbox(make_vec3(bb1(2), bb2(0), bb2(2)),
                                      make_vec3(bb1(3), bb2(1), bb2(3)))
                        };
                    if octant >= 0 { make_gpu_ordered_bbox(bbox, octant) } else { bbox }
                },
                child: |i| children(i),
                prefetch: || {} // No-op
            }
        },
        tri: |j| {
            let tri_ptr = &bvh2.tris(j) as &[1][simd[float * 4]];
            let tri0 = nvvm_ldg4_f32(&tri_ptr(0));
            let tri1 = nvvm_ldg4_f32(&tri_ptr(1));
            let tri2 = nvvm_ldg4_f32(&tri_ptr(2));
            BvhTri {
                load: |i| {
                    let v0 = make_vec3(tri0(0), tri0(1), tri0(2));
                    let e1 = make_vec3(tri1(0), tri1(1), tri1(2));
                    let e2 = make_vec3(tri2(0), tri2(1), tri2(2));
                    let n  = make_vec3(tri0(3), tri1(3), vec3_cross(e1, e2).z);
                    make_tri(v0, e1, e2, n)
                },
                id: |i| bitcast[int](tri2(3)),
                size: 1
            }
        },
        arity: 2
    }
}

// Ray-box intrinsics  -------------------------------------------------------------

fn make_ray_box_intrinsics_nvvm() -> RayBoxIntrinsics {
    // Use video instructions to speed-up the ray-box test
    RayBoxIntrinsics {
        fminf: nvvm_fminf,
        fmaxf: nvvm_fmaxf,
        fminminf: |a, b, c| bitcast[float](nvvm_minmin(bitcast[int](a), bitcast[int](b), bitcast[int](c))),
        fmaxmaxf: |a, b, c| bitcast[float](nvvm_maxmax(bitcast[int](a), bitcast[int](b), bitcast[int](c))),
        fminmaxf: |a, b, c| bitcast[float](nvvm_minmax(bitcast[int](a), bitcast[int](b), bitcast[int](c))),
        fmaxminf: |a, b, c| bitcast[float](nvvm_maxmin(bitcast[int](a), bitcast[int](b), bitcast[int](c))),
        fcmp_le: |a, b| a <= b
    }
}

// Ray layouts  --------------------------------------------------------------------

fn make_gpu_ray_layout(rays: &[Ray1AoS], hits: &mut[Hit1AoS]) -> RayLayout {
    RayLayout {
        packet_size: 1,
        input: |i, j| {
            let ray_ptr = &rays(i + j) as &[1][simd[float * 4]];
            let ray0 = nvvm_ldg4_f32(&ray_ptr(0));
            let ray1 = nvvm_ldg4_f32(&ray_ptr(1));
            make_ray(make_vec3(ray0(0), ray0(1), ray0(2)),
                     make_vec3(ray1(0), ray1(1), ray1(2)),
             ray0(3), ray1(3))
        },
        output: |i, j, hit| {
            *(&hits(i + j) as &mut simd[float * 4]) =
                simd[bitcast[float](hit.prim_id), hit.distance, hit.uv_coords.x, hit.uv_coords.y];
        }
    }
}

// Variants  -----------------------------------------------------------------------

fn gpu_traverse(config: TraversalConfig, bvh: Bvh, ray_layout: RayLayout, ray_count: int) -> () {
    let block_size = 64;
    let grid  = (ray_count, ray_layout.packet_size, 1);
    let block = (block_size, ray_layout.packet_size, 1);
    let acc   = nvvm_accelerator(0);

    with acc.exec(grid, block) @{
        let (i, j) = (acc.tidx() + acc.bidx() * acc.bdimx(), acc.tidy());
        if (i + j) >= ray_count { break() }

        let ray = ray_layout.input(i, j);

        let stack = allocate_stack();
        stack.push(1, 0.0f);

        let mapping = TraversalMapping {
            iterate_children: |node_ref, tmax, stack, body, exit| -> ! @{
                let node = bvh.node(node_ref.node - 1);

                let mut found = false;
                for k in @unroll(0, bvh.arity) @{
                    let (hit, t, _) = body(node.bbox(k, -1));
                    if hit @{
                        let child = node.child(k);
                        if !found { @stack.set_top(child, 0.0f); }
                        else {
                            if t < stack.top().tmin {
                                @stack.push(child, 0.0f);
                            } else {
                                @stack.push_after(child, 0.0f);
                            }
                        }
                    }
                    found |= hit;
                }
                if !found { @stack.pop() }
            },
            iterate_primitives: |leaf_ref, tmax, body, exit| -> ! {
                let mut tri_id = !leaf_ref.node;
                while true @{
                    let tri = bvh.tri(tri_id++);

                    for k in @unroll(0, tri.size) @{
                        @body(make_ray_tri_intersector(tri.load(k), tri.id(k) & 0x7FFFFFFF));
                    }

                    if (bitcast[uint](tri.id(tri.size - 1)) & 0x80000000u) != 0u { break() }
                }
            },
            iterate_instances: |_, _, _| {},
            intrinsics: nvvm_intrinsics,
            ray_box_intrinsics: make_ray_box_intrinsics_nvvm(),
            ray_box_ordered: false
        };

        ray_layout.output(i, j, @traverse_bvh(mapping, config, stack, ray))
    }
}
