// Vectorizer intrinsics  ----------------------------------------------------------

extern "C" {
    fn "rv_any"     any(bool) -> bool;
    fn "rv_all"     all(bool) -> bool;
    fn "rv_ballot"  ballot(bool) -> int;
    fn "rv_extract" extract(float, int) -> float;
    fn "rv_insert"  insert(float, int, float) -> float;
    fn "rv_align"   align(&i8, int)-> &i8;
}

// Misc. ---------------------------------------------------------------------------

// Loads a bounding box ordered by octant on the CPU
fn make_cpu_ordered_bbox(bounds_ptr: &[i8], k: int, octant: int, size: int) -> BBox {
    let (ox, oy, oz) = (octant & 1, (octant >> 1) & 1, (octant >> 2) & 1);
    let (ix, iy, iz) = (ox * size, 2 * size + oy * size, 4 * size + oz * size);

    let (xmin, ymin, zmin) = (
        *(align(&bounds_ptr((ix ^ size) + k), size) as &float),
        *(align(&bounds_ptr((iy ^ size) + k), size) as &float),
        *(align(&bounds_ptr((iz ^ size) + k), size) as &float)
    );
    let (xmax, ymax, zmax) = (
        *(align(&bounds_ptr(ix + k), size) as &float),
        *(align(&bounds_ptr(iy + k), size) as &float),
        *(align(&bounds_ptr(iz + k), size) as &float)
    );

    make_bbox(make_vec3(xmin, ymin, zmin), make_vec3(xmax, ymax, zmax))
}

// Iterate over the bit that are set in a mask
fn one_bits(mask: int, body: fn (int) -> ()) -> () {
    if mask != 0 {
        let lane = cpu_ctz32(mask, true);
        body(lane);
        one_bits(mask & (mask - 1), body);
    }
}

// Lane extraction from vectorized structures
fn extract_int(i: int, lane: int) -> int { bitcast[int](extract(bitcast[float](i), lane)) }
fn extract_vec2(v: Vec2, lane: int) -> Vec2 { vec2_map(v, |x| extract(x, lane)) }
fn extract_vec3(v: Vec3, lane: int) -> Vec3 { vec3_map(v, |x| extract(x, lane)) }
fn extract_vec4(v: Vec4, lane: int) -> Vec4 { vec4_map(v, |x| extract(x, lane)) }
fn extract_hit(hit: Hit, lane: int) -> Hit {
    Hit {
        inst_id:   extract_int(hit.inst_id, lane),
        prim_id:   extract_int(hit.prim_id, lane),
        distance:  extract(hit.distance, lane),
        uv_coords: extract_vec2(hit.uv_coords, lane)
    }
}
fn extract_ray(ray: Ray, lane: int) -> Ray {
    Ray {
        org: extract_vec3(ray.org, lane),
        dir: extract_vec3(ray.dir, lane),
        inv_dir: extract_vec3(ray.inv_dir, lane),
        inv_org: extract_vec3(ray.inv_org, lane),
        tmin: extract(ray.tmin, lane),
        tmax: extract(ray.tmax, lane)
    }
}

// Lane insertion into vectorized structures
fn insert_int(i: int, lane: int, j: int) -> int { bitcast[int](insert(bitcast[float](i), lane, bitcast[float](j))) }
fn insert_vec2(v: Vec2, lane: int, w: Vec2) -> Vec2 { vec2_zip(v, w, |x, y| insert(x, lane, y)) }
fn insert_vec3(v: Vec3, lane: int, w: Vec3) -> Vec3 { vec3_zip(v, w, |x, y| insert(x, lane, y)) }
fn insert_vec4(v: Vec4, lane: int, w: Vec4) -> Vec4 { vec4_zip(v, w, |x, y| insert(x, lane, y)) }
fn insert_hit(hit: Hit, lane: int, elem: Hit) -> Hit {
    Hit {
        inst_id:   insert_int(hit.inst_id, lane, elem.inst_id),
        prim_id:   insert_int(hit.prim_id, lane, elem.prim_id),
        distance:  insert(hit.distance, lane, elem.distance),
        uv_coords: insert_vec2(hit.uv_coords, lane, elem.uv_coords)
    }
}

// BVH4 ----------------------------------------------------------------------------

struct Bvh4 {
    nodes: &[Bvh4Node],
    tris:  &[Bvh4Tri]
}

struct Bvh4Tri {
    v0: [[float * 4] * 3],
    e1: [[float * 4] * 3],
    e2: [[float * 4] * 3],
    n:  [[float * 4] * 3],
    id:  [int   * 4]
}

struct Bvh4Node {
    bounds: [[float * 4] * 6],
    child:   [int   * 4],
    pad:     [int   * 4]
}

fn make_cpu_bvh4(bvh4: Bvh4) -> Bvh {
    Bvh {
        node: |j| {
            let node_ptr = align(&bvh4.nodes(j) as &i8, 16) as &Bvh4Node;
            BvhNode {
                bbox: |i, octant| if octant >= 0 {
                    make_cpu_ordered_bbox(&node_ptr.bounds as &[i8], i, octant, 16)
                } else {
                    make_bbox(make_vec3(node_ptr.bounds(0)(i), node_ptr.bounds(2)(i), node_ptr.bounds(4)(i)),
                              make_vec3(node_ptr.bounds(1)(i), node_ptr.bounds(3)(i), node_ptr.bounds(5)(i)))
                },
                child: |i| node_ptr.child(i),
                prefetch: || {
                    let ptr = node_ptr as &[u8];
                    cpu_prefetch(&ptr(0),  0 /* read */, 3 /* closest locality */, 1 /* data */);
                    cpu_prefetch(&ptr(64), 0 /* read */, 3 /* closest locality */, 1 /* data */);
                }
            }
        },
        tri: |j| {
            let tri_ptr = align(&bvh4.tris(j) as &i8, 16) as &Bvh4Tri;
            BvhTri {
                load: |i| {
                    make_tri(make_vec3(tri_ptr.v0(0)(i), tri_ptr.v0(1)(i), tri_ptr.v0(2)(i)),
                             make_vec3(tri_ptr.e1(0)(i), tri_ptr.e1(1)(i), tri_ptr.e1(2)(i)),
                             make_vec3(tri_ptr.e2(0)(i), tri_ptr.e2(1)(i), tri_ptr.e2(2)(i)),
                             make_vec3(tri_ptr. n(0)(i), tri_ptr. n(1)(i), tri_ptr. n(2)(i)))
                },
                id: |i| tri_ptr.id(i),
                size: 4
            }
        },
        arity: 4
    }
}

// BVH8 ----------------------------------------------------------------------------

struct Bvh8 {
    nodes: &[Bvh8Node],
    tris:  &[Bvh8Tri]
}

struct Bvh8Tri {
    v0: [[float * 8] * 3],
    e1: [[float * 8] * 3],
    e2: [[float * 8] * 3],
    n:  [[float * 8] * 3],
    id:  [int   * 8]
}

struct Bvh8Node {
    bounds: [[float * 8] * 6],
    child:   [int   * 8],
    pad:     [int   * 8]
}

fn make_cpu_bvh8(bvh8: Bvh8) -> Bvh {
    Bvh {
        node: |j| {
            let node_ptr = align(&bvh8.nodes(j) as &i8, 32) as &Bvh8Node;
            BvhNode {
                bbox: |i, octant| if octant >= 0 {
                    make_cpu_ordered_bbox(&node_ptr.bounds as &[i8], i, octant, 32)
                } else {
                    make_bbox(make_vec3(node_ptr.bounds(0)(i), node_ptr.bounds(2)(i), node_ptr.bounds(4)(i)),
                              make_vec3(node_ptr.bounds(1)(i), node_ptr.bounds(3)(i), node_ptr.bounds(5)(i)))
                },
                child: |i| node_ptr.child(i),
                prefetch: || {
                    let ptr = node_ptr as &[u8];
                    cpu_prefetch(&ptr(0),   0 /* read */, 3 /* closest locality */, 1 /* data */);
                    cpu_prefetch(&ptr(64),  0 /* read */, 3 /* closest locality */, 1 /* data */);
                    cpu_prefetch(&ptr(128), 0 /* read */, 3 /* closest locality */, 1 /* data */);
                    cpu_prefetch(&ptr(192), 0 /* read */, 3 /* closest locality */, 1 /* data */);
                }
            }
        },
        tri: |j| {
            let tri_ptr = align(&bvh8.tris(j) as &i8, 32) as &Bvh8Tri;
            BvhTri {
                load: |i| {
                    make_tri(make_vec3(tri_ptr.v0(0)(i), tri_ptr.v0(1)(i), tri_ptr.v0(2)(i)),
                             make_vec3(tri_ptr.e1(0)(i), tri_ptr.e1(1)(i), tri_ptr.e1(2)(i)),
                             make_vec3(tri_ptr.e2(0)(i), tri_ptr.e2(1)(i), tri_ptr.e2(2)(i)),
                             make_vec3(tri_ptr. n(0)(i), tri_ptr. n(1)(i), tri_ptr. n(2)(i)))
                },
                id: |i| tri_ptr.id(i),
                size: 8
            }
        },
        arity: 8
    }
}

// Ray-box intrinsics  -------------------------------------------------------------

fn make_ray_box_intrinsics_avx() -> RayBoxIntrinsics {
    make_ray_box_intrinsics(cpu_intrinsics.fminf, cpu_intrinsics.fmaxf, |a, b| a <= b)
}

fn make_ray_box_intrinsics_avx2() -> RayBoxIntrinsics {
    // AVX2 intrinsics: use integer min/max instead of floating point min/max
    let fminf = |x, y| {
        let (x_, y_) = (bitcast[int](x), bitcast[int](y));
        bitcast[float](select(x_ < y_, x_, y_))
    };
    let fmaxf = |x, y| {
        let (x_, y_) = (bitcast[int](x), bitcast[int](y));
        bitcast[float](select(x_ > y_, x_, y_))
    };
    make_ray_box_intrinsics(fminf, fmaxf, |a, b| { bitcast[int](a) <= bitcast[int](b) })
}

// Ray layouts  --------------------------------------------------------------------

fn make_cpu_ray1_layout(rays: &[Ray1AoS], hits: &mut [Hit1AoS]) -> RayLayout {
    RayLayout {
        packet_size: 1,
        input: |i, j| {
            let ray = &rays(i + j);
            make_ray(make_vec3(ray.org(0), ray.org(1), ray.org(2)),
                     make_vec3(ray.dir(0), ray.dir(1), ray.dir(2)),
                     ray.tmin, ray.tmax)
        },
        output: |i, j, result| {
            let hit = &mut hits(i + j);
            hit.tri_id = result.prim_id;
            hit.t = result.distance;
            hit.u = result.uv_coords.x;
            hit.v = result.uv_coords.y;
        }
    }
}

fn make_cpu_ray4_layout(rays: &[Ray4SoA], hits: &mut [Hit4SoA]) -> RayLayout {
    RayLayout {
        packet_size: 4,
        input: |i, j| {
            let ray = &rays(i);
            make_ray(make_vec3(ray.org(0)(j), ray.org(1)(j), ray.org(2)(j)),
                     make_vec3(ray.dir(0)(j), ray.dir(1)(j), ray.dir(2)(j)),
                     ray.tmin(j), ray.tmax(j))
        },
        output: |i, j, result| {
            let hit = &mut hits(i);
            hit.tri_id(j) = result.prim_id;
            hit.t(j) = result.distance;
            hit.u(j) = result.uv_coords.x;
            hit.v(j) = result.uv_coords.y;
        }
    }
}

fn make_cpu_ray8_layout(rays: &[Ray8SoA], hits: &mut [Hit8SoA]) -> RayLayout {
    RayLayout {
        packet_size: 8,
        input: |i, j| {
            let ray = &rays(i);
            make_ray(make_vec3(ray.org(0)(j), ray.org(1)(j), ray.org(2)(j)),
                     make_vec3(ray.dir(0)(j), ray.dir(1)(j), ray.dir(2)(j)),
                     ray.tmin(j), ray.tmax(j))
        },
        output: |i, j, result| {
            let hit = &mut hits(i);
            hit.tri_id(j) = result.prim_id;
            hit.t(j) = result.distance;
            hit.u(j) = result.uv_coords.x;
            hit.v(j) = result.uv_coords.y;
        }
    }
}

// Mappings  -----------------------------------------------------------------------

fn make_cpu_single_mapping(ray_box_intrinsics: RayBoxIntrinsics, config: TraversalConfig, bvh: Bvh, k: int, octant: int) -> TraversalMapping {
    TraversalMapping {
        iterate_children: |stack, ray, hit, body| @{
            while likely($is_inner(stack.top())) @{
                let node_ref = stack.top();
                stack.pop();
                if unlikely(node_ref.tmin > ray.tmax) { continue() }

                let node = @bvh.node(node_ref.node - 1);
                let (hit, tentry, _) = @body(@node.bbox(k, octant));

                // Use double negation because there is no integer <= on AVX2, only >
                let mask = !ballot(!hit) & ((1 << bvh.arity) - 1);
                if likely(mask == 0) { continue() }

                // Push intersected nodes on the stack
                let mut n = 0;
                for bit in one_bits(mask) {
                    let child_id = node.child(bit);
                    if unlikely(child_id == 0) { break() }

                    @bvh.node(child_id - 1).prefetch();

                    let t = extract(tentry, bit);
                    @stack.push(child_id, t);
                    n++;
                }

                // Sort them
                if !config.any_hit && unlikely(n >= 2) @{
                    stack.push(stack.top().node, stack.top().tmin);
                    // Generate a specialized sorting network for lengths [2..bvh.arity] (included)
                    for i in @unroll(2, bvh.arity + 1) {
                        if n == i @{
                            stack.sort_n(i);
                            break()
                        }
                    }
                    stack.pop()
                }
            }
        },
        iterate_primitives: |leaf_ref, ray, body, exit| -> ! @{
            if unlikely(leaf_ref.tmin > ray.tmax) { exit() }

            let mut tri_id = !leaf_ref.node;
            while true @{
                let tri = bvh.tri(tri_id++);

                // This assumes that the number of triangles per packet is a
                // multiple of the BVH arity (which is also the vector width)
                for i in @unroll(0, tri.size / bvh.arity) {
                    let closest_intr : Intersector = |math, ray, intr| @{
                        // Compute the intersection for each lane
                        let (found, t, u, v) = @intersect_ray_tri(math, ray, tri.load(i + k));

                        // Find the closest intersection
                        let mask = ballot(found);
                        if mask != 0 {
                            let mut closest_hit = empty_hit(ray.tmax);
                            for lane in one_bits(mask) @{
                                let tri_id = tri.id(i + lane);
                                if tri_id == bitcast[int](0xFFFFFFFFu) { exit() }

                                let tlane = extract(t, lane);
                                if config.any_hit || tlane < closest_hit.distance @{
                                    closest_hit.prim_id = tri_id & 0x7FFFFFFF;
                                    closest_hit.uv_coords = @make_vec2(extract(u, lane), extract(v, lane));
                                    closest_hit.distance = tlane;
                                    if config.any_hit { break() }
                                }
                            }
                            @intr(closest_hit)
                        }
                    };

                    @body(closest_intr);
                }

                if (tri.id(tri.size - 1) & bitcast[i32](0x80000000u)) != 0 { exit() }
            }
            exit()
        },
        intrinsics: cpu_intrinsics,
        ray_box_intrinsics: ray_box_intrinsics,
        ray_box_ordered: true
    }
}

fn make_cpu_hybrid_mapping(ray_box_intrinsics: RayBoxIntrinsics, config: TraversalConfig, bvh: Bvh, packet_only: bool, vector_width: int) -> TraversalMapping @{
    let switch_threshold = match vector_width {
        4  =>  3,
        8  =>  5,
        16 => 14,
        _  => vector_width // Be conservative with unknown SIMD widths
    };

    TraversalMapping {
        iterate_children: |stack, ray, hit, body, exit| -> ! @{
            let node_ref = stack.top();
            stack.pop();

            let mask = ballot(node_ref.tmin <= ray.tmax);
            if unlikely(mask == 0) { exit() }

            if !packet_only && unlikely(cpu_popcount32(mask) <= switch_threshold) {
                // Switch to single ray tracing when SIMD utilization is too low
                for lane in $one_bits(mask) {
                    // Traverse the current BVH node using single ray traversal
                    let lane_ray = extract_ray(*ray, lane);
                    let lane_hit = @cpu_traverse_single_helper(ray_box_intrinsics, config, bvh, lane_ray, node_ref.node);
                    if lane_hit.prim_id >= 0 @{
                        *hit = insert_hit(*hit, lane, lane_hit);
                        ray.tmax = insert(ray.tmax, lane, lane_hit.distance);
                    }
                }
                exit()
            }

            // Intersect the node with the packet of rays
            let node = bvh.node(node_ref.node - 1);
            for k in @unroll(0, bvh.arity) @{
                let child_id = node.child(k);
                if unlikely(child_id == 0) { break() }

                let (hit, tentry, _) = @body(node.bbox(k, -1));

                if any(hit) {
                    if config.any_hit || any(stack.top().tmin > tentry) {
                        @stack.push(child_id, tentry);
                    } else {
                        @stack.push_after(child_id, tentry);
                    }
                }
            }
            exit()
        },
        iterate_primitives: |leaf_ref, ray, body, exit| -> ! @{
            if all(leaf_ref.tmin > ray.tmax) { exit() }

            let mut tri_id = !leaf_ref.node;
            while true @{
                let tri = bvh.tri(tri_id++);
                for k in @unroll(0, tri.size) @{
                    let tri_id = tri.id(k);
                    if tri_id == bitcast[int](0xFFFFFFFFu) { exit() }

                    body(make_ray_tri_intersector(tri.load(k), tri_id & 0x7FFFFFFF));
                }
                if (tri.id(tri.size - 1) & bitcast[i32](0x80000000u)) != 0 { exit() }
            }
            exit()
        },
        intrinsics: cpu_intrinsics,
        ray_box_intrinsics: ray_box_intrinsics,
        ray_box_ordered: false
    }
}

// Variants  -----------------------------------------------------------------------

fn cpu_traverse_single_helper(ray_box_intrinsics: RayBoxIntrinsics, config: TraversalConfig, bvh: Bvh, ray: Ray, root: int) -> Hit @{
    let mut hit = empty_hit(ray.tmax);
    for k in vectorize(bvh.arity, bvh.arity * sizeof[float](), 0, bvh.arity) @{
        let stack = allocate_stack();

        stack.push(root, ray.tmin);
        let mapping = @make_cpu_single_mapping(ray_box_intrinsics, config, bvh, k, ray_octant(ray));
        hit = @traverse_bvh(mapping, config, stack, ray);
    }
    hit
}

fn cpu_traverse_packet(ray_box_intrinsics: RayBoxIntrinsics, config: TraversalConfig, bvh: Bvh, ray_layout: RayLayout, ray_count: int) -> () {
    let inc = ray_layout.packet_size;
    for i in $range(0, ray_count / inc) {
        for j in vectorize(inc, inc * sizeof[float](), 0, inc) @{
            let ray = ray_layout.input(i, j);
            let stack = allocate_stack();

            stack.push(1, ray.tmin);

            let mapping = @make_cpu_hybrid_mapping(ray_box_intrinsics, config, bvh, true, inc);
            @ray_layout.output(i, j, @traverse_bvh(mapping, config, stack, ray));
        }
    }
}

fn cpu_traverse_hybrid(ray_box_intrinsics: RayBoxIntrinsics, config: TraversalConfig, bvh: Bvh, ray_layout: RayLayout, ray_count: int) -> () {
    let inc = ray_layout.packet_size;
    for i in $range(0, ray_count / inc) {
        for j in vectorize(inc, inc * sizeof[float](), 0, inc) @{
            let ray = ray_layout.input(i, j);
            let stack = allocate_stack();

            stack.push(1, ray.tmin);

            let mapping = @make_cpu_hybrid_mapping(ray_box_intrinsics, config, bvh, false, inc);
            @ray_layout.output(i, j, @traverse_bvh(mapping, config, stack, ray));
        }
    }
}

fn cpu_traverse_single(ray_box_intrinsics: RayBoxIntrinsics, config: TraversalConfig, bvh: Bvh, ray_layout: RayLayout, ray_count: int) -> () {
    let inc = ray_layout.packet_size;
    for i in $range(0, ray_count) @{
        let (packet_id, ray_id) = (i / inc, i % inc);
        let ray = ray_layout.input(packet_id, ray_id);
        let hit = cpu_traverse_single_helper(ray_box_intrinsics, config, bvh, ray, 1);
        @ray_layout.output(packet_id, ray_id, hit);
    }
}
