struct Bvh4 {
    nodes: &[Bvh4Node],
    tris:  &[Bvh4Tri]
}

struct Bvh4Tri {
    v0: [[float * 4] * 3],
    e1: [[float * 4] * 3],
    e2: [[float * 4] * 3],
    n:  [[float * 4] * 3],
    id:  [int   * 4]
}

struct Bvh4Node {
    min:   [[float * 4] * 3],
    max:   [[float * 4] * 3],
    child:  [int   * 4]
}

// Vectorizer intrinsics
extern "C" {
    fn "rv_any"     any(bool) -> bool;
    fn "rv_all"     all(bool) -> bool;
    fn "rv_ballot"  ballot(bool) -> int;
    fn "rv_extract" extractf(float, int) -> float;
    fn "rv_extract" extracti(int, int) -> int;
    fn "rv_extract" extractv3(Vec3, int) -> Vec3;
    fn "rv_extract" extractv2(Vec2, int) -> Vec3;
}

fn make_ray_box_intrinsics_avx() -> RayBoxIntrinsics {
    make_ray_box_intrinsics(cpu_intrinsics.fminf, cpu_intrinsics.fmaxf)
}

fn make_ray_box_intrinsics_avx2() -> RayBoxIntrinsics {
    // AVX2 intrinsics: use integer min/max instead of floating point min/max
    let fminf = |x, y| {
        let (x_, y_) = (bitcast[int](x), bitcast[int](y));
        bitcast[float](select(x_ < y_, x_, y_))
    };
    let fmaxf = |x, y| {
        let (x_, y_) = (bitcast[int](x), bitcast[int](y));
        bitcast[float](select(x_ < y_, x_, y_))
    };
    make_ray_box_intrinsics(fminf, fmaxf)
}

fn load_bvh4_tri(tri: &Bvh4Tri, i: int) -> Tri @{
    make_tri(make_vec3(tri.v0(0)(i), tri.v0(1)(i), tri.v0(2)(i)),
             make_vec3(tri.e1(0)(i), tri.e1(1)(i), tri.e1(2)(i)),
             make_vec3(tri.e2(0)(i), tri.e2(1)(i), tri.e2(2)(i)),
             make_vec3(tri. n(0)(i), tri. n(1)(i), tri. n(2)(i)))
}

fn make_cpu_ray1_layout(rays: &[Ray1AoS], hits: &mut [Hit1AoS]) -> RayLayout {
    RayLayout {
        increment: || 1,
        input: |i, j| {
            let ray = &rays(i + j);
            (make_ray(make_vec3(ray.org(0), ray.org(1), ray.org(2)),
                      make_vec3(ray.dir(0), ray.dir(1), ray.dir(2))),
                      ray.tmin, ray.tmax)
        },
        output: |i, j, result| {
            let hit = &mut hits(i + j);
            hit.tri_id = result.prim_id;
            hit.t = result.intr.distance;
            hit.u = result.intr.uv_coords.x;
            hit.v = result.intr.uv_coords.y;
        }
    }
}

fn make_cpu_ray4_layout(rays: &[Ray4SoA], hits: &mut [Hit4SoA]) -> RayLayout {
    RayLayout {
        increment: || 4,
        input: |i, j| {
            let ray = &rays(i);
            (make_ray(make_vec3(ray.org(0)(j), ray.org(1)(j), ray.org(2)(j)),
                      make_vec3(ray.dir(0)(j), ray.dir(1)(j), ray.dir(2)(j))),
                      ray.tmin(j), ray.tmax(j))
        },
        output: |i, j, result| {
            let hit = &mut hits(i);
            hit.tri_id(j) = result.prim_id;
            hit.t(j) = result.intr.distance;
            hit.u(j) = result.intr.uv_coords.x;
            hit.v(j) = result.intr.uv_coords.y;
        }
    }
}

fn make_cpu_ray8_layout(rays: &[Ray8SoA], hits: &mut [Hit8SoA]) -> RayLayout {
    RayLayout {
        increment: || 8,
        input: |i, j| {
            let ray = &rays(i);
            (make_ray(make_vec3(ray.org(0)(j), ray.org(1)(j), ray.org(2)(j)),
                      make_vec3(ray.dir(0)(j), ray.dir(1)(j), ray.dir(2)(j))),
                      ray.tmin(j), ray.tmax(j))
        },
        output: |i, j, result| {
            let hit = &mut hits(i);
            hit.tri_id(j) = result.prim_id;
            hit.t(j) = result.intr.distance;
            hit.u(j) = result.intr.uv_coords.x;
            hit.v(j) = result.intr.uv_coords.y;
        }
    }
}

fn cpu_traverse_bvh4_packet(bvh: &Bvh4, ray_layout: RayLayout, ray_count: int, any_hit: bool) -> () {
    let inc = ray_layout.increment();
    for i in $range(0, ray_count / inc) {
        for j in vectorize(inc, 32, 0, inc) @{
            let (ray, tmin, tmax) = ray_layout.input(i, j);
            let stack = allocate_stack();

            stack.push(0, tmin);

            let mapping = TraversalMapping {
                iterate_children: |node_ref, tmax, stack, body, exit| -> ! @{
                    stack.pop();

                    if all(node_ref.tmin > tmax) { exit() }

                    let node = &bvh.nodes(node_ref.node);
                    for k in @unroll(0, 4) @{
                        pe_info("child", k);
                        if node.child(k) == 0 { break() }

                        let bbox = make_bbox(make_vec3(node.min(0)(k), node.min(1)(k), node.min(2)(k)),
                                             make_vec3(node.max(0)(k), node.max(1)(k), node.max(2)(k)));
                        let intersect_child = |box| -> (bool, float) {
                            @body(box, |tentry, _, _| -> ! { return(true, tentry) });
                            (false, 0.0f)
                        };
                        let (hit, tentry) = @intersect_child(bbox);

                        if any(hit) {
                            if any(stack.top().tmin > tentry) {
                                stack.push(node.child(k), tentry);
                            } else {
                                stack.push_after(node.child(k), tentry);
                            }
                        }
                    }
                },
                iterate_primitives: |leaf_ref, tmax, body, exit| -> ! @{
                    if all(leaf_ref.tmin > tmax) { exit() }

                    let mut tri_id = !leaf_ref.node;
                    while true @{
                        let tri = &bvh.tris(tri_id++);
                        for k in @unroll(0, 4) {
                            @body(make_primitive(make_ray_tri_intersector(load_bvh4_tri(tri, k)), tri.id(k) & 0x7FFFFFFF));
                        }
                        if (tri.id(3) & bitcast[i32](0x80000000u)) != 0 { break() }
                    }
                },
                iterate_instances: |_, _, _| {},
                hit_callback: |hit, continue, terminate| -> !
                    if any_hit && all(hit.prim_id >= 0) { @terminate(hit) } else { continue() },
                transparency: |_, _| false,
                is_leaf: |node_ref| node_ref.node < 0,
                intrinsics: cpu_intrinsics,
                ray_box_intrinsics: make_ray_box_intrinsics_avx2()
            };

            ray_layout.output(i, j, @traverse_bvh(mapping, stack, ray, tmin, tmax));
        }
    }
}

fn cpu_traverse_bvh4_single(bvh: &Bvh4, ray_layout: RayLayout, ray_count: int, any_hit: bool) -> () {
    let inc = ray_layout.increment();
    for i in $range_step(0, ray_count, inc) @{
        for j in range(0, inc) {
            let (ray, tmin, tmax) = ray_layout.input(i, j);
            for k in vectorize(4, 16, 0, 4) {
                let stack = allocate_stack();

                stack.push(0, tmin);

                let mapping = TraversalMapping {
                    iterate_children: |node_ref, tmax, stack, body, exit| -> ! {
                        stack.pop();

                        if node_ref.tmin > tmax { exit() }

                        let node = &bvh.nodes(node_ref.node);
                        let bbox = make_bbox(make_vec3(node.min(0)(k), node.min(1)(k), node.min(2)(k)),
                                             make_vec3(node.max(0)(k), node.max(1)(k), node.max(2)(k)));

                        let mut child = -1;
                        let mut tentry : float;
                        body(bbox, |t, _| {
                            tentry = t;
                            child = node.child(j);
                        });

                        // Push intersected nodes on the stack
                        let mut count = 0;
                        for lane in @range(0, 4) {
                            let c = extracti(child, lane);
                            if c >= 0 {
                                stack.push(c, extractf(tentry, lane));
                                count++;
                            }
                        }

                        // Sort the nodes on the stack, based on their distance
                        if count < 2 { exit() }
                        if count == 2 {
                            @stack.sort_n(2);
                        } else if count == 3 {
                            @stack.sort_n(3);
                        } else if count == 4 {
                            @stack.sort_n(4);
                        }
                    },
                    iterate_primitives: |leaf_ref, tmax, body, exit| -> ! {
                        if leaf_ref.tmin > tmax { exit() }

                        let mut tri_id = !leaf_ref.node;
                        while true {
                            let tri = &bvh.tris(tri_id++);
                            /*let closest_intr = |math, ray, tmin, tmax, intr| {
                                let mut found = false;
                                let mut t  = flt_max;
                                let mut n  = vec3(0.0f, 0.0f, 0.0f);
                                let mut uv = vec2(0.0f, 0.0f);

                                make_ray_tri_intersector(load_bvh4_tri(tri, j))
                                    (math, ray, tmin, tmax, |hit| {
                                        n  = hit.normal();
                                        uv = hit.uv();
                                        t  = hit.distance();
                                        found = true;
                                    });

                                if any(found) {
                                    let mut id = 0;
                                    if extractf(t, 1) < extractf(t, 0) { id = 1; }
                                    if extractf(t, 2) < extractf(t, 3) { id = 2; }
                                }
                            };*/
                            // TODO: Select the closest ray-triangle intersection within the intersector
                            @body(make_primitive(make_ray_tri_intersector(load_bvh4_tri(tri, k)), tri.id(k) & 0x7FFFFFFF));
                            if (tri.id(3) & bitcast[i32](0x80000000u)) != 0 { break() }
                        }
                    },
                    iterate_instances: |_, _, _| {},
                    hit_callback: |hit, continue, terminate| -> !
                        if any_hit && hit.prim_id >= 0 { terminate(hit) } else { continue() },
                    transparency: |_, _| false,
                    is_leaf: |node_ref| node_ref.node < 0,
                    intrinsics: cpu_intrinsics,
                    ray_box_intrinsics: make_ray_box_intrinsics_avx2()
                };

                ray_layout.output(i, j, @traverse_bvh(mapping, stack, ray, tmin, tmax));
            }
        }
    }
}
