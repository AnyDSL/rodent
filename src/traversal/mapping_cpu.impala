struct Bvh4 {
    nodes: &[Bvh4Node],
    tris:  &[Bvh4Tri]
}

struct Bvh4Tri {
    v0: [[float * 4] * 3],
    e1: [[float * 4] * 3],
    e2: [[float * 4] * 3],
    n:  [[float * 4] * 3],
    id:  [int   * 4]
}

struct Bvh4Node {
    min:   [[float * 4] * 3],
    max:   [[float * 4] * 3],
    child:  [int   * 4]
}

// Vectorizer intrinsics
extern "C" {
    fn "rv_any"     any(bool) -> bool;
    fn "rv_all"     all(bool) -> bool;
    fn "rv_ballot"  ballot(bool) -> int;
    fn "rv_extract" extractf(float, int) -> float;
    fn "rv_extract" extracti(int, int) -> int;
}

fn ray_box_intrinsics_avx() -> RayBoxIntrinsics {
    ray_box_intrinsics(cpu_intrinsics.fminf, cpu_intrinsics.fmaxf)
}

fn ray_box_intrinsics_avx2() -> RayBoxIntrinsics {
    // AVX2 intrinsics: use integer min/max instead of floating point min/max
    let fminf = |x, y| {
        let (x_, y_) = (bitcast[int](x), bitcast[int](y));
        bitcast[float](if x_ < y_ { x_ } else { y_ })
    };
    let fmaxf = |x, y| {
        let (x_, y_) = (bitcast[int](x), bitcast[int](y));
        bitcast[float](if x_ > y_ { x_ } else { y_ })
    };
    ray_box_intrinsics(fminf, fmaxf)
}

fn load_bvh4_tri(tri: &Bvh4Tri, i: int) -> Tri @{
    make_tri(vec3(tri.v0(0)(i), tri.v0(1)(i), tri.v0(2)(i)),
             vec3(tri.e1(0)(i), tri.e1(1)(i), tri.e1(2)(i)),
             vec3(tri.e2(0)(i), tri.e2(1)(i), tri.e2(2)(i)),
             vec3(tri. n(0)(i), tri. n(1)(i), tri. n(2)(i)))
}

fn cpu_traverse_bvh4_packet(bvh: &Bvh4, rays: RayStream, hits: HitStream, ray_count: int, any_hit: bool) -> () {
    for i in $range_step(0, ray_count, 8) {
        for j in vectorize(8, 32, 0, 8) @{
            let (ray, tmin, tmax) = rays(i + j);
            let stack = alloc_stack();

            stack.push(0, tmin);

            let mapping = TraversalMapping {
                iterate_children: |node_ref, tmax, stack, body, exit| -> ! @{
                    stack.pop();

                    if all(node_ref.tmin > tmax) { exit() }

                    let node = bvh.nodes(node_ref.node);
                    for k in @range(0, 4) @{
                        if node.child(k) == 0 { break() }

                        let bbox = make_bbox(vec3(node.min(0)(k), node.min(1)(k), node.min(2)(k)),
                                             vec3(node.max(0)(k), node.max(1)(k), node.max(2)(k)));
                        let intersect_child = |box| -> (bool, float) {
                            @body(box, |tentry, _, _| -> ! { return(true, tentry) });
                            (false, 0.0f)
                        };
                        let (hit, tentry) = @intersect_child(bbox);

                        if any(hit) {
                            if any(stack.top().tmin > tentry) {
                                stack.push(node.child(k), tentry);
                            } else {
                                stack.push_after(node.child(k), tentry);
                            }
                        }
                    }
                },
                iterate_primitives: |leaf_ref, tmax, body, exit| -> ! @{
                    if all(leaf_ref.tmin > tmax) { exit() }

                    let mut tri_id = !leaf_ref.node;
                    while true @{
                        let tri = bvh.tris(tri_id++);
                        for k in @range(0, 4) {
                            @body(make_primitive(ray_tri_intersector(load_bvh4_tri(tri, k)), tri.id(k) & 0x7FFFFFFF));
                        }
                        if (tri.id(3) & bitcast[i32](0x80000000u)) != 0 { break() }
                    }
                },
                iterate_instances: |_, _, _| {},
                hit_callback: |hit, continue, terminate| -> !
                    if any_hit && all(hit.prim_id() >= 0) { @terminate(hit) } else { continue() },
                transparency: |_, _| false,
                is_leaf: |node_ref| node_ref.node < 0,
                intrinsics: cpu_intrinsics,
                ray_box_intrinsics: ray_box_intrinsics_avx2()
            };

            hits(i + j, @traverse_bvh(mapping, stack, ray, tmin, tmax));
        }
    }
}

fn cpu_traverse_bvh4_single(bvh: &Bvh4, rays: RayStream, hits: HitStream, ray_count: int, any_hit: bool) -> () {
    for i in range(0, ray_count) {
        let (ray, tmin, tmax) = rays(i);

        for j in vectorize(4, 16, 0, 4) {
            let stack = alloc_stack();

            stack.push(0, tmin);

            let mapping = TraversalMapping {
                iterate_children: |node_ref, tmax, stack, body, exit| -> ! {
                    stack.pop();

                    if node_ref.tmin > tmax { exit() }

                    let node = bvh.nodes(node_ref.node);
                    let bbox = make_bbox(vec3(node.min(0)(j), node.min(1)(j), node.min(2)(j)),
                                         vec3(node.max(0)(j), node.max(1)(j), node.max(2)(j)));

                    let mut child = -1;
                    let mut tentry : float;
                    body(bbox, |t, _| {
                        tentry = t;
                        child = node.child(j);
                    });

                    // Push intersected nodes on the stack
                    let mut count = 0;
                    for k in @range(0, 4) {
                        let c = extracti(child, k);
                        if c >= 0 {
                            stack.push(c, extractf(tentry, k));
                            count++;
                        }
                    }

                    // Sort the nodes on the stack, based on their distance
                    if count < 2 { exit() }
                    if count == 2 {
                        @stack.sort_n(2);
                    } else if count == 3 {
                        @stack.sort_n(3);
                    } else if count == 4 {
                        @stack.sort_n(4);
                    }
                },
                iterate_primitives: |leaf_ref, tmax, body, exit| -> ! {
                    if leaf_ref.tmin > tmax { exit() }

                    let mut tri_id = !leaf_ref.node;
                    while true {
                        let tri = bvh.tris(tri_id++);
                        // TODO: Select the closest ray-triangle intersection within the intersector
                        @body(make_primitive(ray_tri_intersector(load_bvh4_tri(tri, j)), tri.id(j) & 0x7FFFFFFF));
                        if (tri.id(3) & bitcast[i32](0x80000000u)) != 0 { break() }
                    }
                },
                iterate_instances: |_, _, _| {},
                hit_callback: |hit, continue, terminate| -> !
                    if any_hit && hit.prim_id() >= 0 { terminate(hit) } else { continue() },
                transparency: |_, _| false,
                is_leaf: |node_ref| node_ref.node < 0,
                intrinsics: cpu_intrinsics,
                ray_box_intrinsics: ray_box_intrinsics_avx()
            };

            hits(i, @traverse_bvh(mapping, stack, ray, tmin, tmax));
        }
    }
}
