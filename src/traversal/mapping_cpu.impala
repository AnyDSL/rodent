struct Bvh4 {
    nodes: &[Bvh4Node],
    tris:  &[Bvh4Tri]
}

struct Bvh4Tri {
    v0: [[float * 4] * 3],
    e1: [[float * 4] * 3],
    e2: [[float * 4] * 3],
    n:  [[float * 4] * 3],
    id:  [int   * 4]
}

struct Bvh4Node {
    bounds: [[float * 4] * 6],
    child:  [int   * 4]
}

fn load_bvh4_tri(tri: &Bvh4Tri, i: int) -> Tri @{
    make_tri(make_vec3(tri.v0(0)(i), tri.v0(1)(i), tri.v0(2)(i)),
             make_vec3(tri.e1(0)(i), tri.e1(1)(i), tri.e1(2)(i)),
             make_vec3(tri.e2(0)(i), tri.e2(1)(i), tri.e2(2)(i)),
             make_vec3(tri. n(0)(i), tri. n(1)(i), tri. n(2)(i)))
}

fn prefetch_bvh4_node(node: &Bvh4Node) -> () {
    let ptr = node as &[u8];
    cpu_prefetch(&ptr(0),  0 /* read */, 3 /* locality */, 1 /* data */);
    cpu_prefetch(&ptr(64), 0 /* read */, 3 /* locality */, 1 /* data */);
}

// Vectorizer intrinsics  ----------------------------------------------------------

extern "C" {
    fn "rv_any"     any(bool) -> bool;
    fn "rv_all"     all(bool) -> bool;
    fn "rv_ballot"  ballot(bool) -> int;
    fn "rv_extract" extractf(float, int) -> float;
}

fn extracti(v: int, i: int) -> int {
    bitcast[int](extractf(bitcast[float](v), i))
}

// Ray-box intrinsics  -------------------------------------------------------------

fn make_ray_box_intrinsics_avx() -> RayBoxIntrinsics {
    make_ray_box_intrinsics(cpu_intrinsics.fminf, cpu_intrinsics.fmaxf, |a, b| a <= b)
}

fn make_ray_box_intrinsics_avx2() -> RayBoxIntrinsics {
    // AVX2 intrinsics: use integer min/max instead of floating point min/max
    let fminf = |x, y| {
        let (x_, y_) = (bitcast[int](x), bitcast[int](y));
        bitcast[float](select(x_ < y_, x_, y_))
    };
    let fmaxf = |x, y| {
        let (x_, y_) = (bitcast[int](x), bitcast[int](y));
        bitcast[float](select(x_ > y_, x_, y_))
    };
    make_ray_box_intrinsics(fminf, fmaxf, |a, b| { bitcast[int](a) <= bitcast[int](b) })
}

// Ray layouts  --------------------------------------------------------------------

fn make_cpu_ray1_layout(rays: &[Ray1AoS], hits: &mut [Hit1AoS]) -> RayLayout {
    RayLayout {
        packet_size: 1,
        input: |i, j| {
            let ray = &rays(i + j);
            make_ray(make_vec3(ray.org(0), ray.org(1), ray.org(2)),
                     make_vec3(ray.dir(0), ray.dir(1), ray.dir(2)),
                     ray.tmin, ray.tmax)
        },
        output: |i, j, result| {
            let hit = &mut hits(i + j);
            hit.tri_id = result.prim_id;
            hit.t = result.distance;
            hit.u = result.uv_coords.x;
            hit.v = result.uv_coords.y;
        }
    }
}

fn make_cpu_ray4_layout(rays: &[Ray4SoA], hits: &mut [Hit4SoA]) -> RayLayout {
    RayLayout {
        packet_size: 4,
        input: |i, j| {
            let ray = &rays(i);
            make_ray(make_vec3(ray.org(0)(j), ray.org(1)(j), ray.org(2)(j)),
                     make_vec3(ray.dir(0)(j), ray.dir(1)(j), ray.dir(2)(j)),
                     ray.tmin(j), ray.tmax(j))
        },
        output: |i, j, result| {
            let hit = &mut hits(i);
            hit.tri_id(j) = result.prim_id;
            hit.t(j) = result.distance;
            hit.u(j) = result.uv_coords.x;
            hit.v(j) = result.uv_coords.y;
        }
    }
}

fn make_cpu_ray8_layout(rays: &[Ray8SoA], hits: &mut [Hit8SoA]) -> RayLayout {
    RayLayout {
        packet_size: 8,
        input: |i, j| {
            let ray = &rays(i);
            make_ray(make_vec3(ray.org(0)(j), ray.org(1)(j), ray.org(2)(j)),
                     make_vec3(ray.dir(0)(j), ray.dir(1)(j), ray.dir(2)(j)),
                     ray.tmin(j), ray.tmax(j))
        },
        output: |i, j, result| {
            let hit = &mut hits(i);
            hit.tri_id(j) = result.prim_id;
            hit.t(j) = result.distance;
            hit.u(j) = result.uv_coords.x;
            hit.v(j) = result.uv_coords.y;
        }
    }
}

// Mappings  -----------------------------------------------------------------------

fn make_cpu_packet_bvh4_mapping(bvh: &Bvh4, ray_box_intrinsics: RayBoxIntrinsics) -> TraversalMapping {
    let (nodes, tris) = (bvh.nodes, bvh.tris);
    TraversalMapping {
        iterate_children: |node_ref, tmax, stack, body, exit| -> ! @{
            stack.pop();

            if all(node_ref.tmin > tmax) { exit() }

            let node = &nodes(node_ref.node - 1);
            for k in @unroll(0, 4) @{
                let child_id = node.child(k);
                if child_id == 0 { break() }

                let bbox = @make_bbox(make_vec3(node.bounds(0)(k), node.bounds(2)(k), node.bounds(4)(k)),
                                      make_vec3(node.bounds(1)(k), node.bounds(3)(k), node.bounds(5)(k)));

                let mut hit = false;
                let mut tentry;
                @body(bbox, |t, _| { tentry = t; hit = true; });

                if any(hit) {
                    if any(stack.top().tmin > tentry) {
                        stack.push(child_id, tentry);
                    } else {
                        stack.push_after(child_id, tentry);
                    }
                }
            }
        },
        iterate_primitives: |leaf_ref, tmax, body, exit| -> ! @{
            if all(leaf_ref.tmin > tmax) { exit() }

            let mut tri_id = !leaf_ref.node;
            while true @{
                let tri = &tris(tri_id++);
                for k in @unroll(0, 4) @{
                    body(make_ray_tri_intersector(load_bvh4_tri(tri, k), tri.id(k) & 0x7FFFFFFF));
                }
                if (tri.id(3) & bitcast[i32](0x80000000u)) != 0 { break() }
            }
        },
        iterate_instances: |_, _, _| {},
        intrinsics: cpu_intrinsics,
        ray_box_intrinsics: ray_box_intrinsics,
        ray_box_ordered: false
    }
}

fn make_cpu_single_bvh4_mapping(k: int, octant: int, bvh: &Bvh4, ray_box_intrinsics: RayBoxIntrinsics) -> TraversalMapping {
    let (nodes, tris) = (bvh.nodes, bvh.tris);
    let (ox, oy, oz) = (octant & 1, (octant >> 1) & 1, (octant >> 2) & 1);
    let indices = [ ox * 4, 8 + oy * 4, 16 + oz * 4 ];

    // Iterate over the bit that are set in a mask
    fn one_bits(mask: int, body: fn (int) -> ()) -> () {
        if mask != 0 {
            let lane = cpu_ctz32(mask, true);
            body(lane);
            one_bits(mask & !(1 << lane), body);
        }
    }

    // Hack to get a vector extract with a variable index
    fn as_vector(f: float) -> simd[float * 4] {
        simd[ extractf(f, 0), extractf(f, 1), extractf(f, 2), extractf(f, 3) ]
    }

    TraversalMapping {
        iterate_children: |node_ref, tmax, stack, body, exit| -> ! @{
            stack.pop();
            if unlikely(node_ref.tmin > tmax) { exit() }

            let node = &nodes(node_ref.node - 1);
            let bounds_ptr = &node.bounds as &[float];
            let (ix, iy, iz) = (indices(0), indices(1), indices(2));
            let bbox = @make_bbox(@make_vec3(bounds_ptr((ix ^ 4) + k), bounds_ptr((iy ^ 4) + k), bounds_ptr((iz ^ 4) + k)),
                                  @make_vec3(bounds_ptr( ix      + k), bounds_ptr( iy      + k), bounds_ptr( iz      + k)));

            let mut hit = false;
            let mut tentry;
            @body(bbox, |t, _| { tentry = t; hit = true; });
            let tvector = as_vector(tentry);

            // Push intersected nodes on the stack
            let mask = ballot(hit);
            for lane in one_bits(mask) {
                let child_id = node.child(lane);
                if child_id == 0 { break() }

                let t = tvector(lane);
                prefetch_bvh4_node(&nodes(child_id - 1));
                if stack.top().tmin > t {
                    @stack.push(child_id, t);
                } else {
                    @stack.push_after(child_id, t);
                }
            }

            let count = cpu_popcount32(mask);
            if count == 3 { @stack.sort_n(3) }
            else if count == 4 { @stack.sort_n(4) }
        },
        iterate_primitives: |leaf_ref, tmax, body, exit| -> ! @{
            if unlikely(leaf_ref.tmin > tmax) { exit() }

            let mut tri_id = !leaf_ref.node;
            while true @{
                let tri = &tris(tri_id++);
                let closest_intr : Intersector = |math, ray, intr| @{
                    let mut found = false;
                    let mut t;
                    let mut uv;

                    // Compute the intersection for each lane
                    let intersect = make_ray_tri_intersector(load_bvh4_tri(tri, k), tri.id(k) & 0x7FFFFFFF);
                    @intersect(math, ray, |hit| @{
                        uv = hit.uv_coords;
                        t = hit.distance;
                        found = true;
                    });

                    // Find the closest intersection
                    let mask = ballot(found);
                    if mask != 0 {
                        let tvector = as_vector(t);
                        let uvector = as_vector(uv.x);
                        let vvector = as_vector(uv.y);
                        let mut hit = @make_hit(-1, -1, flt_max, undef());
                        for lane in one_bits(mask) {
                            let tlane = tvector(lane);
                            if tlane < hit.distance @{
                                hit.prim_id = tri.id(lane) & 0x7FFFFFFF;
                                hit.uv_coords = make_vec2(uvector(lane), vvector(lane));
                                hit.distance = tlane;
                            }
                        }
                        @intr(hit);
                    }
                };
                @body(closest_intr);
                if (tri.id(3) & bitcast[i32](0x80000000u)) != 0 { break() }
            }
        },
        iterate_instances: |_, _, _| {},
        intrinsics: cpu_intrinsics,
        ray_box_intrinsics: ray_box_intrinsics,
        ray_box_ordered: true
    }
}

// Variants  -----------------------------------------------------------------------

fn cpu_traverse_bvh4_packet_avx2(config: TraversalConfig, bvh: &Bvh4, ray_layout: RayLayout, ray_count: int) -> () {
    let inc = ray_layout.packet_size;
    for i in $range(0, ray_count / inc) {
        for j in vectorize(inc, 32, 0, inc) @{
            let ray = ray_layout.input(i, j);
            let stack = allocate_stack();

            stack.push(1, ray.tmin);

            let mapping = @make_cpu_packet_bvh4_mapping(bvh, make_ray_box_intrinsics_avx2());
            @ray_layout.output(i, j, @traverse_bvh(mapping, config, stack, ray));
        }
    }
}

fn cpu_traverse_bvh4_single_avx2(config: TraversalConfig, bvh: &Bvh4, ray_layout: RayLayout, ray_count: int) -> () {
    let inc = ray_layout.packet_size;
    for i in $range(0, ray_count) @{
        let (packet_id, ray_id) = (i / inc, i % inc);
        let ray = ray_layout.input(packet_id, ray_id);

        for k in vectorize(4, 16, 0, 4) @{
            let stack = allocate_stack();

            stack.push(1, ray.tmin);

            let mapping = @make_cpu_single_bvh4_mapping(k, ray_octant(ray), bvh, make_ray_box_intrinsics_avx2());
            @ray_layout.output(packet_id, ray_id, @traverse_bvh(mapping, config, stack, ray));
        }
    }
}
