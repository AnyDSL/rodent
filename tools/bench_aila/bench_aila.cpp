#include <iostream>
#include <fstream>
#include <chrono>
#include <numeric>
#include <algorithm>
#include <string>
#include <cstring>
#include <functional>
#include <vector>

#include "traversal.h"
#include "load_bvh.h"
#include "load_rays.h"

void setup_traversal(const Node2* nodes, size_t num_nodes, const Tri1* tris, size_t num_tris);
void shutdown_traversal();
void bench_traversal(const Ray1* rays, Hit1* hits, int num_rays, double* timings, int ntimes, bool any);

inline void check_argument(int i, int argc, char** argv) {
    if (i + 1 >= argc) {
        std::cerr << "Missing argument for " << argv[i] << std::endl;
        exit(1);
    }
}

inline void usage() {
    std::cout << "Usage: bench_aila [options]\n"
                 "Available options:\n"
                 "  -bvh     --bvh-file        Sets the BVH file to use\n"
                 "  -ray     --ray-file        Sets the ray file to use\n"
                 "           --tmin            Sets the minimum distance along the rays (default: 0)\n"
                 "           --tmax            Sets the maximum distance along the rays (default: 1e9)\n"
                 "           --bench           Sets the number of benchmark iterations (default: 1)\n"
                 "           --warmup          Sets the number of warmup iterations (default: 0)\n"
                 "  -any                       Exit at the first intersection (disabled by default)\n"
                 "  -o       --output          Sets the output file name (no file is generated by default)\n";
}

static void transform_nodes(Node2* nodes, size_t size) {
    for (size_t i = 0; i < size; ++i) {
        Node2 copy = nodes[i];
        nodes[i].bounds[4] = copy.bounds[6];
        nodes[i].bounds[5] = copy.bounds[7];
        nodes[i].bounds[6] = copy.bounds[8];
        nodes[i].bounds[7] = copy.bounds[9];
        nodes[i].bounds[8] = copy.bounds[4];
        nodes[i].bounds[9] = copy.bounds[5];
    }
}

int main(int argc, char** argv) {
    std::string ray_file;
    std::string bvh_file;
    std::string out_file;
    float tmin = 0.0f, tmax = 1e9f;
    int iters = 1;
    int warmup = 0;
    bool any_hit = false;

    for (int i = 1; i < argc; i++) {
        auto arg = argv[i];
        if (arg[0] == '-') {
            if (!strcmp(arg, "-h") || !strcmp(arg, "--help")) {
                usage();
                return 0;
            } else if (!strcmp(arg, "-bvh") || !strcmp(arg, "--bvh-file")) {
                check_argument(i, argc, argv);
                bvh_file = argv[++i];
            } else if (!strcmp(arg, "-ray") || !strcmp(arg, "--ray-file")) {
                check_argument(i, argc, argv);
                ray_file = argv[++i];
            } else if (!strcmp(arg, "--tmin")) {
                check_argument(i, argc, argv);
                tmin = strtof(argv[++i], nullptr);
            } else if (!strcmp(arg, "--tmax")) {
                check_argument(i, argc, argv);
                tmax = strtof(argv[++i], nullptr);
            } else if (!strcmp(arg, "--bench")) {
                check_argument(i, argc, argv);
                iters = strtol(argv[++i], nullptr, 10);
            } else if (!strcmp(arg, "--warmup")) {
                check_argument(i, argc, argv);
                warmup = strtol(argv[++i], nullptr, 10);
            } else if (!strcmp(arg, "-any")) {
                any_hit = true;
            } else if (!strcmp(arg, "-o") || !strcmp(arg, "--output")) {
                check_argument(i, argc, argv);
                out_file = argv[++i];
            } else {
                std::cerr << "Unknown option '" << arg << "'" << std::endl;
                return 1;
            }
        } else {
            std::cerr << "Invalid argument '" << arg << "'" << std::endl;
            return 1;
        }
    }

    if (bvh_file == "") {
        std::cerr << "No BVH file specified" << std::endl;
        return 1;
    }
    if (ray_file == "") {
        std::cerr << "No ray file specified" << std::endl;
        return 1;
    }

    anydsl::Array<Node2> nodes;
    anydsl::Array<Tri1>  tris;
    if (!load_bvh(bvh_file, nodes, tris, BvhType::BVH2_TRI1, anydsl::Platform::Host, anydsl::Device(0))) {
        std::cerr << "Cannot load BVH file" << std::endl;
        return 1;
    }

    transform_nodes(nodes.data(), nodes.size());

    anydsl::Array<Ray1> rays;
    if (!load_rays(ray_file, rays, tmin, tmax, anydsl::Platform::Host, anydsl::Device(0))) {
        std::cerr << "Cannot load rays" << std::endl;
        return 1;
    }

    std::vector<Hit1> hits(rays.size());
    std::vector<double> timings(iters);

    setup_traversal(nodes.data(), nodes.size(), tris.data(), tris.size());
    bench_traversal(rays.data(), hits.data(), rays.size(), nullptr, warmup, any_hit);
    bench_traversal(rays.data(), hits.data(), rays.size(), timings.data(), iters, any_hit);
    shutdown_traversal();

    size_t intr = 0;
    for (auto& hit : hits) intr += (hit.tri_id >= 0);

    if (out_file != "") {
        std::ofstream of(out_file, std::ofstream::binary);
        for (auto& hit : hits)
            of.write((char*)&hit.t, sizeof(float));
    }

    std::sort(timings.begin(), timings.end());
    auto sum = std::accumulate(timings.begin(), timings.end(), 0.0);
    auto avg = sum / timings.size();
    auto med = timings[timings.size() / 2];
    auto min = *std::min_element(timings.begin(), timings.end());
    std::cout << sum << "ms for " << iters << " iteration(s)" << std::endl;
    std::cout << rays.size() * iters / (1000.0 * sum) << " Mrays/sec" << std::endl;
    std::cout << "# Average: " << avg << " ms" << std::endl;
    std::cout << "# Median: " << med  << " ms" << std::endl;
    std::cout << "# Min: " << min << " ms" << std::endl;
    std::cout << intr << " intersection(s)" << std::endl;
    return 0;
}
